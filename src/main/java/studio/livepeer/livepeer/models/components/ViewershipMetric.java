/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Double;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import studio.livepeer.livepeer.utils.Utils;

/**
 * ViewershipMetric - An individual metric about viewership of a stream/asset. Necessarily, at least
 * 1 of playbackId and dStorageUrl will be present, depending on the query.
 * 
 */

public class ViewershipMetric {

    /**
     * The playback ID associated with the metric.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackId")
    private Optional<String> playbackId;

    /**
     * The ID of the creator associated with the metric.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private Optional<String> creatorId;

    /**
     * The ID of the viewer associated with the metric.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewerId")
    private Optional<String> viewerId;

    /**
     * The URL of the distributed storage used for the asset
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dStorageUrl")
    private Optional<String> dStorageUrl;

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timestamp")
    private Optional<Double> timestamp;

    /**
     * The device used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("device")
    private Optional<String> device;

    /**
     * The type of the device used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceType")
    private Optional<String> deviceType;

    /**
     * The CPU used by the viewer's device.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cpu")
    private Optional<String> cpu;

    /**
     * The operating system used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("os")
    private Optional<String> os;

    /**
     * The browser used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("browser")
    private Optional<String> browser;

    /**
     * The browser engine used by the viewer's browser.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("browserEngine")
    private Optional<String> browserEngine;

    /**
     * The continent where the viewer is located.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("continent")
    private Optional<String> continent;

    /**
     * The country where the viewer is located.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("country")
    private Optional<String> country;

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subdivision")
    private Optional<String> subdivision;

    /**
     * The timezone where the viewer is located.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timezone")
    private Optional<String> timezone;

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("geohash")
    private Optional<String> geohash;

    /**
     * The number of views for the stream/asset.
     */
    @JsonProperty("viewCount")
    private long viewCount;

    /**
     * The total playtime in minutes for the stream/asset.
     */
    @JsonProperty("playtimeMins")
    private double playtimeMins;

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ttffMs")
    private Optional<Double> ttffMs;

    /**
     * The rebuffering ratio for the asset.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("rebufferRatio")
    private Optional<Double> rebufferRatio;

    /**
     * The error rate for the stream/asset.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("errorRate")
    private Optional<Double> errorRate;

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exitsBeforeStart")
    private Optional<Double> exitsBeforeStart;

    @JsonCreator
    public ViewershipMetric(
            @JsonProperty("playbackId") Optional<String> playbackId,
            @JsonProperty("creatorId") Optional<String> creatorId,
            @JsonProperty("viewerId") Optional<String> viewerId,
            @JsonProperty("dStorageUrl") Optional<String> dStorageUrl,
            @JsonProperty("timestamp") Optional<Double> timestamp,
            @JsonProperty("device") Optional<String> device,
            @JsonProperty("deviceType") Optional<String> deviceType,
            @JsonProperty("cpu") Optional<String> cpu,
            @JsonProperty("os") Optional<String> os,
            @JsonProperty("browser") Optional<String> browser,
            @JsonProperty("browserEngine") Optional<String> browserEngine,
            @JsonProperty("continent") Optional<String> continent,
            @JsonProperty("country") Optional<String> country,
            @JsonProperty("subdivision") Optional<String> subdivision,
            @JsonProperty("timezone") Optional<String> timezone,
            @JsonProperty("geohash") Optional<String> geohash,
            @JsonProperty("viewCount") long viewCount,
            @JsonProperty("playtimeMins") double playtimeMins,
            @JsonProperty("ttffMs") Optional<Double> ttffMs,
            @JsonProperty("rebufferRatio") Optional<Double> rebufferRatio,
            @JsonProperty("errorRate") Optional<Double> errorRate,
            @JsonProperty("exitsBeforeStart") Optional<Double> exitsBeforeStart) {
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(creatorId, "creatorId");
        Utils.checkNotNull(viewerId, "viewerId");
        Utils.checkNotNull(dStorageUrl, "dStorageUrl");
        Utils.checkNotNull(timestamp, "timestamp");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(deviceType, "deviceType");
        Utils.checkNotNull(cpu, "cpu");
        Utils.checkNotNull(os, "os");
        Utils.checkNotNull(browser, "browser");
        Utils.checkNotNull(browserEngine, "browserEngine");
        Utils.checkNotNull(continent, "continent");
        Utils.checkNotNull(country, "country");
        Utils.checkNotNull(subdivision, "subdivision");
        Utils.checkNotNull(timezone, "timezone");
        Utils.checkNotNull(geohash, "geohash");
        Utils.checkNotNull(viewCount, "viewCount");
        Utils.checkNotNull(playtimeMins, "playtimeMins");
        Utils.checkNotNull(ttffMs, "ttffMs");
        Utils.checkNotNull(rebufferRatio, "rebufferRatio");
        Utils.checkNotNull(errorRate, "errorRate");
        Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
        this.playbackId = playbackId;
        this.creatorId = creatorId;
        this.viewerId = viewerId;
        this.dStorageUrl = dStorageUrl;
        this.timestamp = timestamp;
        this.device = device;
        this.deviceType = deviceType;
        this.cpu = cpu;
        this.os = os;
        this.browser = browser;
        this.browserEngine = browserEngine;
        this.continent = continent;
        this.country = country;
        this.subdivision = subdivision;
        this.timezone = timezone;
        this.geohash = geohash;
        this.viewCount = viewCount;
        this.playtimeMins = playtimeMins;
        this.ttffMs = ttffMs;
        this.rebufferRatio = rebufferRatio;
        this.errorRate = errorRate;
        this.exitsBeforeStart = exitsBeforeStart;
    }
    
    public ViewershipMetric(
            long viewCount,
            double playtimeMins) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), viewCount, playtimeMins, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The playback ID associated with the metric.
     */
    @JsonIgnore
    public Optional<String> playbackId() {
        return playbackId;
    }

    /**
     * The ID of the creator associated with the metric.
     */
    @JsonIgnore
    public Optional<String> creatorId() {
        return creatorId;
    }

    /**
     * The ID of the viewer associated with the metric.
     */
    @JsonIgnore
    public Optional<String> viewerId() {
        return viewerId;
    }

    /**
     * The URL of the distributed storage used for the asset
     */
    @JsonIgnore
    public Optional<String> dStorageUrl() {
        return dStorageUrl;
    }

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    @JsonIgnore
    public Optional<Double> timestamp() {
        return timestamp;
    }

    /**
     * The device used by the viewer.
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * The type of the device used by the viewer.
     */
    @JsonIgnore
    public Optional<String> deviceType() {
        return deviceType;
    }

    /**
     * The CPU used by the viewer's device.
     */
    @JsonIgnore
    public Optional<String> cpu() {
        return cpu;
    }

    /**
     * The operating system used by the viewer.
     */
    @JsonIgnore
    public Optional<String> os() {
        return os;
    }

    /**
     * The browser used by the viewer.
     */
    @JsonIgnore
    public Optional<String> browser() {
        return browser;
    }

    /**
     * The browser engine used by the viewer's browser.
     */
    @JsonIgnore
    public Optional<String> browserEngine() {
        return browserEngine;
    }

    /**
     * The continent where the viewer is located.
     */
    @JsonIgnore
    public Optional<String> continent() {
        return continent;
    }

    /**
     * The country where the viewer is located.
     */
    @JsonIgnore
    public Optional<String> country() {
        return country;
    }

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    @JsonIgnore
    public Optional<String> subdivision() {
        return subdivision;
    }

    /**
     * The timezone where the viewer is located.
     */
    @JsonIgnore
    public Optional<String> timezone() {
        return timezone;
    }

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    @JsonIgnore
    public Optional<String> geohash() {
        return geohash;
    }

    /**
     * The number of views for the stream/asset.
     */
    @JsonIgnore
    public long viewCount() {
        return viewCount;
    }

    /**
     * The total playtime in minutes for the stream/asset.
     */
    @JsonIgnore
    public double playtimeMins() {
        return playtimeMins;
    }

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    @JsonIgnore
    public Optional<Double> ttffMs() {
        return ttffMs;
    }

    /**
     * The rebuffering ratio for the asset.
     */
    @JsonIgnore
    public Optional<Double> rebufferRatio() {
        return rebufferRatio;
    }

    /**
     * The error rate for the stream/asset.
     */
    @JsonIgnore
    public Optional<Double> errorRate() {
        return errorRate;
    }

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    @JsonIgnore
    public Optional<Double> exitsBeforeStart() {
        return exitsBeforeStart;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The playback ID associated with the metric.
     */
    public ViewershipMetric withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = Optional.ofNullable(playbackId);
        return this;
    }

    /**
     * The playback ID associated with the metric.
     */
    public ViewershipMetric withPlaybackId(Optional<String> playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    /**
     * The ID of the creator associated with the metric.
     */
    public ViewershipMetric withCreatorId(String creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = Optional.ofNullable(creatorId);
        return this;
    }

    /**
     * The ID of the creator associated with the metric.
     */
    public ViewershipMetric withCreatorId(Optional<String> creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = creatorId;
        return this;
    }

    /**
     * The ID of the viewer associated with the metric.
     */
    public ViewershipMetric withViewerId(String viewerId) {
        Utils.checkNotNull(viewerId, "viewerId");
        this.viewerId = Optional.ofNullable(viewerId);
        return this;
    }

    /**
     * The ID of the viewer associated with the metric.
     */
    public ViewershipMetric withViewerId(Optional<String> viewerId) {
        Utils.checkNotNull(viewerId, "viewerId");
        this.viewerId = viewerId;
        return this;
    }

    /**
     * The URL of the distributed storage used for the asset
     */
    public ViewershipMetric withDStorageUrl(String dStorageUrl) {
        Utils.checkNotNull(dStorageUrl, "dStorageUrl");
        this.dStorageUrl = Optional.ofNullable(dStorageUrl);
        return this;
    }

    /**
     * The URL of the distributed storage used for the asset
     */
    public ViewershipMetric withDStorageUrl(Optional<String> dStorageUrl) {
        Utils.checkNotNull(dStorageUrl, "dStorageUrl");
        this.dStorageUrl = dStorageUrl;
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    public ViewershipMetric withTimestamp(double timestamp) {
        Utils.checkNotNull(timestamp, "timestamp");
        this.timestamp = Optional.ofNullable(timestamp);
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    public ViewershipMetric withTimestamp(Optional<Double> timestamp) {
        Utils.checkNotNull(timestamp, "timestamp");
        this.timestamp = timestamp;
        return this;
    }

    /**
     * The device used by the viewer.
     */
    public ViewershipMetric withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }

    /**
     * The device used by the viewer.
     */
    public ViewershipMetric withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * The type of the device used by the viewer.
     */
    public ViewershipMetric withDeviceType(String deviceType) {
        Utils.checkNotNull(deviceType, "deviceType");
        this.deviceType = Optional.ofNullable(deviceType);
        return this;
    }

    /**
     * The type of the device used by the viewer.
     */
    public ViewershipMetric withDeviceType(Optional<String> deviceType) {
        Utils.checkNotNull(deviceType, "deviceType");
        this.deviceType = deviceType;
        return this;
    }

    /**
     * The CPU used by the viewer's device.
     */
    public ViewershipMetric withCpu(String cpu) {
        Utils.checkNotNull(cpu, "cpu");
        this.cpu = Optional.ofNullable(cpu);
        return this;
    }

    /**
     * The CPU used by the viewer's device.
     */
    public ViewershipMetric withCpu(Optional<String> cpu) {
        Utils.checkNotNull(cpu, "cpu");
        this.cpu = cpu;
        return this;
    }

    /**
     * The operating system used by the viewer.
     */
    public ViewershipMetric withOs(String os) {
        Utils.checkNotNull(os, "os");
        this.os = Optional.ofNullable(os);
        return this;
    }

    /**
     * The operating system used by the viewer.
     */
    public ViewershipMetric withOs(Optional<String> os) {
        Utils.checkNotNull(os, "os");
        this.os = os;
        return this;
    }

    /**
     * The browser used by the viewer.
     */
    public ViewershipMetric withBrowser(String browser) {
        Utils.checkNotNull(browser, "browser");
        this.browser = Optional.ofNullable(browser);
        return this;
    }

    /**
     * The browser used by the viewer.
     */
    public ViewershipMetric withBrowser(Optional<String> browser) {
        Utils.checkNotNull(browser, "browser");
        this.browser = browser;
        return this;
    }

    /**
     * The browser engine used by the viewer's browser.
     */
    public ViewershipMetric withBrowserEngine(String browserEngine) {
        Utils.checkNotNull(browserEngine, "browserEngine");
        this.browserEngine = Optional.ofNullable(browserEngine);
        return this;
    }

    /**
     * The browser engine used by the viewer's browser.
     */
    public ViewershipMetric withBrowserEngine(Optional<String> browserEngine) {
        Utils.checkNotNull(browserEngine, "browserEngine");
        this.browserEngine = browserEngine;
        return this;
    }

    /**
     * The continent where the viewer is located.
     */
    public ViewershipMetric withContinent(String continent) {
        Utils.checkNotNull(continent, "continent");
        this.continent = Optional.ofNullable(continent);
        return this;
    }

    /**
     * The continent where the viewer is located.
     */
    public ViewershipMetric withContinent(Optional<String> continent) {
        Utils.checkNotNull(continent, "continent");
        this.continent = continent;
        return this;
    }

    /**
     * The country where the viewer is located.
     */
    public ViewershipMetric withCountry(String country) {
        Utils.checkNotNull(country, "country");
        this.country = Optional.ofNullable(country);
        return this;
    }

    /**
     * The country where the viewer is located.
     */
    public ViewershipMetric withCountry(Optional<String> country) {
        Utils.checkNotNull(country, "country");
        this.country = country;
        return this;
    }

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    public ViewershipMetric withSubdivision(String subdivision) {
        Utils.checkNotNull(subdivision, "subdivision");
        this.subdivision = Optional.ofNullable(subdivision);
        return this;
    }

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    public ViewershipMetric withSubdivision(Optional<String> subdivision) {
        Utils.checkNotNull(subdivision, "subdivision");
        this.subdivision = subdivision;
        return this;
    }

    /**
     * The timezone where the viewer is located.
     */
    public ViewershipMetric withTimezone(String timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = Optional.ofNullable(timezone);
        return this;
    }

    /**
     * The timezone where the viewer is located.
     */
    public ViewershipMetric withTimezone(Optional<String> timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = timezone;
        return this;
    }

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    public ViewershipMetric withGeohash(String geohash) {
        Utils.checkNotNull(geohash, "geohash");
        this.geohash = Optional.ofNullable(geohash);
        return this;
    }

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    public ViewershipMetric withGeohash(Optional<String> geohash) {
        Utils.checkNotNull(geohash, "geohash");
        this.geohash = geohash;
        return this;
    }

    /**
     * The number of views for the stream/asset.
     */
    public ViewershipMetric withViewCount(long viewCount) {
        Utils.checkNotNull(viewCount, "viewCount");
        this.viewCount = viewCount;
        return this;
    }

    /**
     * The total playtime in minutes for the stream/asset.
     */
    public ViewershipMetric withPlaytimeMins(double playtimeMins) {
        Utils.checkNotNull(playtimeMins, "playtimeMins");
        this.playtimeMins = playtimeMins;
        return this;
    }

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    public ViewershipMetric withTtffMs(double ttffMs) {
        Utils.checkNotNull(ttffMs, "ttffMs");
        this.ttffMs = Optional.ofNullable(ttffMs);
        return this;
    }

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    public ViewershipMetric withTtffMs(Optional<Double> ttffMs) {
        Utils.checkNotNull(ttffMs, "ttffMs");
        this.ttffMs = ttffMs;
        return this;
    }

    /**
     * The rebuffering ratio for the asset.
     */
    public ViewershipMetric withRebufferRatio(double rebufferRatio) {
        Utils.checkNotNull(rebufferRatio, "rebufferRatio");
        this.rebufferRatio = Optional.ofNullable(rebufferRatio);
        return this;
    }

    /**
     * The rebuffering ratio for the asset.
     */
    public ViewershipMetric withRebufferRatio(Optional<Double> rebufferRatio) {
        Utils.checkNotNull(rebufferRatio, "rebufferRatio");
        this.rebufferRatio = rebufferRatio;
        return this;
    }

    /**
     * The error rate for the stream/asset.
     */
    public ViewershipMetric withErrorRate(double errorRate) {
        Utils.checkNotNull(errorRate, "errorRate");
        this.errorRate = Optional.ofNullable(errorRate);
        return this;
    }

    /**
     * The error rate for the stream/asset.
     */
    public ViewershipMetric withErrorRate(Optional<Double> errorRate) {
        Utils.checkNotNull(errorRate, "errorRate");
        this.errorRate = errorRate;
        return this;
    }

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    public ViewershipMetric withExitsBeforeStart(double exitsBeforeStart) {
        Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
        this.exitsBeforeStart = Optional.ofNullable(exitsBeforeStart);
        return this;
    }

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    public ViewershipMetric withExitsBeforeStart(Optional<Double> exitsBeforeStart) {
        Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
        this.exitsBeforeStart = exitsBeforeStart;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ViewershipMetric other = (ViewershipMetric) o;
        return 
            Objects.deepEquals(this.playbackId, other.playbackId) &&
            Objects.deepEquals(this.creatorId, other.creatorId) &&
            Objects.deepEquals(this.viewerId, other.viewerId) &&
            Objects.deepEquals(this.dStorageUrl, other.dStorageUrl) &&
            Objects.deepEquals(this.timestamp, other.timestamp) &&
            Objects.deepEquals(this.device, other.device) &&
            Objects.deepEquals(this.deviceType, other.deviceType) &&
            Objects.deepEquals(this.cpu, other.cpu) &&
            Objects.deepEquals(this.os, other.os) &&
            Objects.deepEquals(this.browser, other.browser) &&
            Objects.deepEquals(this.browserEngine, other.browserEngine) &&
            Objects.deepEquals(this.continent, other.continent) &&
            Objects.deepEquals(this.country, other.country) &&
            Objects.deepEquals(this.subdivision, other.subdivision) &&
            Objects.deepEquals(this.timezone, other.timezone) &&
            Objects.deepEquals(this.geohash, other.geohash) &&
            Objects.deepEquals(this.viewCount, other.viewCount) &&
            Objects.deepEquals(this.playtimeMins, other.playtimeMins) &&
            Objects.deepEquals(this.ttffMs, other.ttffMs) &&
            Objects.deepEquals(this.rebufferRatio, other.rebufferRatio) &&
            Objects.deepEquals(this.errorRate, other.errorRate) &&
            Objects.deepEquals(this.exitsBeforeStart, other.exitsBeforeStart);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            playbackId,
            creatorId,
            viewerId,
            dStorageUrl,
            timestamp,
            device,
            deviceType,
            cpu,
            os,
            browser,
            browserEngine,
            continent,
            country,
            subdivision,
            timezone,
            geohash,
            viewCount,
            playtimeMins,
            ttffMs,
            rebufferRatio,
            errorRate,
            exitsBeforeStart);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ViewershipMetric.class,
                "playbackId", playbackId,
                "creatorId", creatorId,
                "viewerId", viewerId,
                "dStorageUrl", dStorageUrl,
                "timestamp", timestamp,
                "device", device,
                "deviceType", deviceType,
                "cpu", cpu,
                "os", os,
                "browser", browser,
                "browserEngine", browserEngine,
                "continent", continent,
                "country", country,
                "subdivision", subdivision,
                "timezone", timezone,
                "geohash", geohash,
                "viewCount", viewCount,
                "playtimeMins", playtimeMins,
                "ttffMs", ttffMs,
                "rebufferRatio", rebufferRatio,
                "errorRate", errorRate,
                "exitsBeforeStart", exitsBeforeStart);
    }
    
    public final static class Builder {
 
        private Optional<String> playbackId = Optional.empty();
 
        private Optional<String> creatorId = Optional.empty();
 
        private Optional<String> viewerId = Optional.empty();
 
        private Optional<String> dStorageUrl = Optional.empty();
 
        private Optional<Double> timestamp = Optional.empty();
 
        private Optional<String> device = Optional.empty();
 
        private Optional<String> deviceType = Optional.empty();
 
        private Optional<String> cpu = Optional.empty();
 
        private Optional<String> os = Optional.empty();
 
        private Optional<String> browser = Optional.empty();
 
        private Optional<String> browserEngine = Optional.empty();
 
        private Optional<String> continent = Optional.empty();
 
        private Optional<String> country = Optional.empty();
 
        private Optional<String> subdivision = Optional.empty();
 
        private Optional<String> timezone = Optional.empty();
 
        private Optional<String> geohash = Optional.empty();
 
        private Long viewCount;
 
        private Double playtimeMins;
 
        private Optional<Double> ttffMs = Optional.empty();
 
        private Optional<Double> rebufferRatio = Optional.empty();
 
        private Optional<Double> errorRate = Optional.empty();
 
        private Optional<Double> exitsBeforeStart = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The playback ID associated with the metric.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = Optional.ofNullable(playbackId);
            return this;
        }

        /**
         * The playback ID associated with the metric.
         */
        public Builder playbackId(Optional<String> playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        /**
         * The ID of the creator associated with the metric.
         */
        public Builder creatorId(String creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = Optional.ofNullable(creatorId);
            return this;
        }

        /**
         * The ID of the creator associated with the metric.
         */
        public Builder creatorId(Optional<String> creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = creatorId;
            return this;
        }

        /**
         * The ID of the viewer associated with the metric.
         */
        public Builder viewerId(String viewerId) {
            Utils.checkNotNull(viewerId, "viewerId");
            this.viewerId = Optional.ofNullable(viewerId);
            return this;
        }

        /**
         * The ID of the viewer associated with the metric.
         */
        public Builder viewerId(Optional<String> viewerId) {
            Utils.checkNotNull(viewerId, "viewerId");
            this.viewerId = viewerId;
            return this;
        }

        /**
         * The URL of the distributed storage used for the asset
         */
        public Builder dStorageUrl(String dStorageUrl) {
            Utils.checkNotNull(dStorageUrl, "dStorageUrl");
            this.dStorageUrl = Optional.ofNullable(dStorageUrl);
            return this;
        }

        /**
         * The URL of the distributed storage used for the asset
         */
        public Builder dStorageUrl(Optional<String> dStorageUrl) {
            Utils.checkNotNull(dStorageUrl, "dStorageUrl");
            this.dStorageUrl = dStorageUrl;
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the metric was recorded. If the
         * query contains a time step, this timestamp will point to the
         * beginning of the time step period.
         * 
         */
        public Builder timestamp(double timestamp) {
            Utils.checkNotNull(timestamp, "timestamp");
            this.timestamp = Optional.ofNullable(timestamp);
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the metric was recorded. If the
         * query contains a time step, this timestamp will point to the
         * beginning of the time step period.
         * 
         */
        public Builder timestamp(Optional<Double> timestamp) {
            Utils.checkNotNull(timestamp, "timestamp");
            this.timestamp = timestamp;
            return this;
        }

        /**
         * The device used by the viewer.
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * The device used by the viewer.
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }

        /**
         * The type of the device used by the viewer.
         */
        public Builder deviceType(String deviceType) {
            Utils.checkNotNull(deviceType, "deviceType");
            this.deviceType = Optional.ofNullable(deviceType);
            return this;
        }

        /**
         * The type of the device used by the viewer.
         */
        public Builder deviceType(Optional<String> deviceType) {
            Utils.checkNotNull(deviceType, "deviceType");
            this.deviceType = deviceType;
            return this;
        }

        /**
         * The CPU used by the viewer's device.
         */
        public Builder cpu(String cpu) {
            Utils.checkNotNull(cpu, "cpu");
            this.cpu = Optional.ofNullable(cpu);
            return this;
        }

        /**
         * The CPU used by the viewer's device.
         */
        public Builder cpu(Optional<String> cpu) {
            Utils.checkNotNull(cpu, "cpu");
            this.cpu = cpu;
            return this;
        }

        /**
         * The operating system used by the viewer.
         */
        public Builder os(String os) {
            Utils.checkNotNull(os, "os");
            this.os = Optional.ofNullable(os);
            return this;
        }

        /**
         * The operating system used by the viewer.
         */
        public Builder os(Optional<String> os) {
            Utils.checkNotNull(os, "os");
            this.os = os;
            return this;
        }

        /**
         * The browser used by the viewer.
         */
        public Builder browser(String browser) {
            Utils.checkNotNull(browser, "browser");
            this.browser = Optional.ofNullable(browser);
            return this;
        }

        /**
         * The browser used by the viewer.
         */
        public Builder browser(Optional<String> browser) {
            Utils.checkNotNull(browser, "browser");
            this.browser = browser;
            return this;
        }

        /**
         * The browser engine used by the viewer's browser.
         */
        public Builder browserEngine(String browserEngine) {
            Utils.checkNotNull(browserEngine, "browserEngine");
            this.browserEngine = Optional.ofNullable(browserEngine);
            return this;
        }

        /**
         * The browser engine used by the viewer's browser.
         */
        public Builder browserEngine(Optional<String> browserEngine) {
            Utils.checkNotNull(browserEngine, "browserEngine");
            this.browserEngine = browserEngine;
            return this;
        }

        /**
         * The continent where the viewer is located.
         */
        public Builder continent(String continent) {
            Utils.checkNotNull(continent, "continent");
            this.continent = Optional.ofNullable(continent);
            return this;
        }

        /**
         * The continent where the viewer is located.
         */
        public Builder continent(Optional<String> continent) {
            Utils.checkNotNull(continent, "continent");
            this.continent = continent;
            return this;
        }

        /**
         * The country where the viewer is located.
         */
        public Builder country(String country) {
            Utils.checkNotNull(country, "country");
            this.country = Optional.ofNullable(country);
            return this;
        }

        /**
         * The country where the viewer is located.
         */
        public Builder country(Optional<String> country) {
            Utils.checkNotNull(country, "country");
            this.country = country;
            return this;
        }

        /**
         * The subdivision (e.g., state or province) where the viewer is
         * located.
         * 
         */
        public Builder subdivision(String subdivision) {
            Utils.checkNotNull(subdivision, "subdivision");
            this.subdivision = Optional.ofNullable(subdivision);
            return this;
        }

        /**
         * The subdivision (e.g., state or province) where the viewer is
         * located.
         * 
         */
        public Builder subdivision(Optional<String> subdivision) {
            Utils.checkNotNull(subdivision, "subdivision");
            this.subdivision = subdivision;
            return this;
        }

        /**
         * The timezone where the viewer is located.
         */
        public Builder timezone(String timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = Optional.ofNullable(timezone);
            return this;
        }

        /**
         * The timezone where the viewer is located.
         */
        public Builder timezone(Optional<String> timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = timezone;
            return this;
        }

        /**
         * Geographic encoding of the viewers location. Accurate to 3 digits.
         */
        public Builder geohash(String geohash) {
            Utils.checkNotNull(geohash, "geohash");
            this.geohash = Optional.ofNullable(geohash);
            return this;
        }

        /**
         * Geographic encoding of the viewers location. Accurate to 3 digits.
         */
        public Builder geohash(Optional<String> geohash) {
            Utils.checkNotNull(geohash, "geohash");
            this.geohash = geohash;
            return this;
        }

        /**
         * The number of views for the stream/asset.
         */
        public Builder viewCount(long viewCount) {
            Utils.checkNotNull(viewCount, "viewCount");
            this.viewCount = viewCount;
            return this;
        }

        /**
         * The total playtime in minutes for the stream/asset.
         */
        public Builder playtimeMins(double playtimeMins) {
            Utils.checkNotNull(playtimeMins, "playtimeMins");
            this.playtimeMins = playtimeMins;
            return this;
        }

        /**
         * The time-to-first-frame (TTFF) in milliseconds.
         */
        public Builder ttffMs(double ttffMs) {
            Utils.checkNotNull(ttffMs, "ttffMs");
            this.ttffMs = Optional.ofNullable(ttffMs);
            return this;
        }

        /**
         * The time-to-first-frame (TTFF) in milliseconds.
         */
        public Builder ttffMs(Optional<Double> ttffMs) {
            Utils.checkNotNull(ttffMs, "ttffMs");
            this.ttffMs = ttffMs;
            return this;
        }

        /**
         * The rebuffering ratio for the asset.
         */
        public Builder rebufferRatio(double rebufferRatio) {
            Utils.checkNotNull(rebufferRatio, "rebufferRatio");
            this.rebufferRatio = Optional.ofNullable(rebufferRatio);
            return this;
        }

        /**
         * The rebuffering ratio for the asset.
         */
        public Builder rebufferRatio(Optional<Double> rebufferRatio) {
            Utils.checkNotNull(rebufferRatio, "rebufferRatio");
            this.rebufferRatio = rebufferRatio;
            return this;
        }

        /**
         * The error rate for the stream/asset.
         */
        public Builder errorRate(double errorRate) {
            Utils.checkNotNull(errorRate, "errorRate");
            this.errorRate = Optional.ofNullable(errorRate);
            return this;
        }

        /**
         * The error rate for the stream/asset.
         */
        public Builder errorRate(Optional<Double> errorRate) {
            Utils.checkNotNull(errorRate, "errorRate");
            this.errorRate = errorRate;
            return this;
        }

        /**
         * The percentage of sessions that existed before the asset started
         * playing.
         * 
         */
        public Builder exitsBeforeStart(double exitsBeforeStart) {
            Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
            this.exitsBeforeStart = Optional.ofNullable(exitsBeforeStart);
            return this;
        }

        /**
         * The percentage of sessions that existed before the asset started
         * playing.
         * 
         */
        public Builder exitsBeforeStart(Optional<Double> exitsBeforeStart) {
            Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
            this.exitsBeforeStart = exitsBeforeStart;
            return this;
        }
        
        public ViewershipMetric build() {
            return new ViewershipMetric(
                playbackId,
                creatorId,
                viewerId,
                dStorageUrl,
                timestamp,
                device,
                deviceType,
                cpu,
                os,
                browser,
                browserEngine,
                continent,
                country,
                subdivision,
                timezone,
                geohash,
                viewCount,
                playtimeMins,
                ttffMs,
                rebufferRatio,
                errorRate,
                exitsBeforeStart);
        }
    }
}

