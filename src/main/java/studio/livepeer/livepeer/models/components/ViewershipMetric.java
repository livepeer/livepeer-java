/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import studio.livepeer.livepeer.utils.Utils;
/**
 * ViewershipMetric - An individual metric about viewership of an asset. Necessarily, at least
 * 1 of playbackId and dStorageUrl will be present, depending on the query.
 * 
 */

public class ViewershipMetric {

    /**
     * The playback ID associated with the metric.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackId")
    private Optional<? extends String> playbackId;

    /**
     * The ID of the creator associated with the metric.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private Optional<? extends String> creatorId;

    /**
     * The ID of the viewer associated with the metric.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewerId")
    private Optional<? extends String> viewerId;

    /**
     * The URL of the distributed storage used for the asset
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dStorageUrl")
    private Optional<? extends String> dStorageUrl;

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timestamp")
    private Optional<? extends Double> timestamp;

    /**
     * The device used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("device")
    private Optional<? extends String> device;

    /**
     * The type of the device used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deviceType")
    private Optional<? extends String> deviceType;

    /**
     * The CPU used by the viewer's device.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cpu")
    private Optional<? extends String> cpu;

    /**
     * The operating system used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("os")
    private Optional<? extends String> os;

    /**
     * The browser used by the viewer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("browser")
    private Optional<? extends String> browser;

    /**
     * The browser engine used by the viewer's browser.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("browserEngine")
    private Optional<? extends String> browserEngine;

    /**
     * The continent where the viewer is located.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("continent")
    private Optional<? extends String> continent;

    /**
     * The country where the viewer is located.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("country")
    private Optional<? extends String> country;

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subdivision")
    private Optional<? extends String> subdivision;

    /**
     * The timezone where the viewer is located.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timezone")
    private Optional<? extends String> timezone;

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("geohash")
    private Optional<? extends String> geohash;

    /**
     * The number of views for the asset.
     */
    @JsonProperty("viewCount")
    private long viewCount;

    /**
     * The total playtime in minutes for the asset.
     */
    @JsonProperty("playtimeMins")
    private double playtimeMins;

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ttffMs")
    private Optional<? extends Double> ttffMs;

    /**
     * The rebuffering ratio for the asset.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("rebufferRatio")
    private Optional<? extends Double> rebufferRatio;

    /**
     * The error rate for the asset.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("errorRate")
    private Optional<? extends Double> errorRate;

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exitsBeforeStart")
    private Optional<? extends Double> exitsBeforeStart;

    @JsonCreator
    public ViewershipMetric(
            @JsonProperty("playbackId") Optional<? extends String> playbackId,
            @JsonProperty("creatorId") Optional<? extends String> creatorId,
            @JsonProperty("viewerId") Optional<? extends String> viewerId,
            @JsonProperty("dStorageUrl") Optional<? extends String> dStorageUrl,
            @JsonProperty("timestamp") Optional<? extends Double> timestamp,
            @JsonProperty("device") Optional<? extends String> device,
            @JsonProperty("deviceType") Optional<? extends String> deviceType,
            @JsonProperty("cpu") Optional<? extends String> cpu,
            @JsonProperty("os") Optional<? extends String> os,
            @JsonProperty("browser") Optional<? extends String> browser,
            @JsonProperty("browserEngine") Optional<? extends String> browserEngine,
            @JsonProperty("continent") Optional<? extends String> continent,
            @JsonProperty("country") Optional<? extends String> country,
            @JsonProperty("subdivision") Optional<? extends String> subdivision,
            @JsonProperty("timezone") Optional<? extends String> timezone,
            @JsonProperty("geohash") Optional<? extends String> geohash,
            @JsonProperty("viewCount") long viewCount,
            @JsonProperty("playtimeMins") double playtimeMins,
            @JsonProperty("ttffMs") Optional<? extends Double> ttffMs,
            @JsonProperty("rebufferRatio") Optional<? extends Double> rebufferRatio,
            @JsonProperty("errorRate") Optional<? extends Double> errorRate,
            @JsonProperty("exitsBeforeStart") Optional<? extends Double> exitsBeforeStart) {
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(creatorId, "creatorId");
        Utils.checkNotNull(viewerId, "viewerId");
        Utils.checkNotNull(dStorageUrl, "dStorageUrl");
        Utils.checkNotNull(timestamp, "timestamp");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(deviceType, "deviceType");
        Utils.checkNotNull(cpu, "cpu");
        Utils.checkNotNull(os, "os");
        Utils.checkNotNull(browser, "browser");
        Utils.checkNotNull(browserEngine, "browserEngine");
        Utils.checkNotNull(continent, "continent");
        Utils.checkNotNull(country, "country");
        Utils.checkNotNull(subdivision, "subdivision");
        Utils.checkNotNull(timezone, "timezone");
        Utils.checkNotNull(geohash, "geohash");
        Utils.checkNotNull(viewCount, "viewCount");
        Utils.checkNotNull(playtimeMins, "playtimeMins");
        Utils.checkNotNull(ttffMs, "ttffMs");
        Utils.checkNotNull(rebufferRatio, "rebufferRatio");
        Utils.checkNotNull(errorRate, "errorRate");
        Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
        this.playbackId = playbackId;
        this.creatorId = creatorId;
        this.viewerId = viewerId;
        this.dStorageUrl = dStorageUrl;
        this.timestamp = timestamp;
        this.device = device;
        this.deviceType = deviceType;
        this.cpu = cpu;
        this.os = os;
        this.browser = browser;
        this.browserEngine = browserEngine;
        this.continent = continent;
        this.country = country;
        this.subdivision = subdivision;
        this.timezone = timezone;
        this.geohash = geohash;
        this.viewCount = viewCount;
        this.playtimeMins = playtimeMins;
        this.ttffMs = ttffMs;
        this.rebufferRatio = rebufferRatio;
        this.errorRate = errorRate;
        this.exitsBeforeStart = exitsBeforeStart;
    }
    
    public ViewershipMetric(
            long viewCount,
            double playtimeMins) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), viewCount, playtimeMins, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The playback ID associated with the metric.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> playbackId() {
        return (Optional<String>) playbackId;
    }

    /**
     * The ID of the creator associated with the metric.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> creatorId() {
        return (Optional<String>) creatorId;
    }

    /**
     * The ID of the viewer associated with the metric.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> viewerId() {
        return (Optional<String>) viewerId;
    }

    /**
     * The URL of the distributed storage used for the asset
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> dStorageUrl() {
        return (Optional<String>) dStorageUrl;
    }

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> timestamp() {
        return (Optional<Double>) timestamp;
    }

    /**
     * The device used by the viewer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> device() {
        return (Optional<String>) device;
    }

    /**
     * The type of the device used by the viewer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> deviceType() {
        return (Optional<String>) deviceType;
    }

    /**
     * The CPU used by the viewer's device.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> cpu() {
        return (Optional<String>) cpu;
    }

    /**
     * The operating system used by the viewer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> os() {
        return (Optional<String>) os;
    }

    /**
     * The browser used by the viewer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> browser() {
        return (Optional<String>) browser;
    }

    /**
     * The browser engine used by the viewer's browser.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> browserEngine() {
        return (Optional<String>) browserEngine;
    }

    /**
     * The continent where the viewer is located.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> continent() {
        return (Optional<String>) continent;
    }

    /**
     * The country where the viewer is located.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> country() {
        return (Optional<String>) country;
    }

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> subdivision() {
        return (Optional<String>) subdivision;
    }

    /**
     * The timezone where the viewer is located.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> timezone() {
        return (Optional<String>) timezone;
    }

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> geohash() {
        return (Optional<String>) geohash;
    }

    /**
     * The number of views for the asset.
     */
    @JsonIgnore
    public long viewCount() {
        return viewCount;
    }

    /**
     * The total playtime in minutes for the asset.
     */
    @JsonIgnore
    public double playtimeMins() {
        return playtimeMins;
    }

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> ttffMs() {
        return (Optional<Double>) ttffMs;
    }

    /**
     * The rebuffering ratio for the asset.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> rebufferRatio() {
        return (Optional<Double>) rebufferRatio;
    }

    /**
     * The error rate for the asset.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> errorRate() {
        return (Optional<Double>) errorRate;
    }

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> exitsBeforeStart() {
        return (Optional<Double>) exitsBeforeStart;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The playback ID associated with the metric.
     */
    public ViewershipMetric withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = Optional.ofNullable(playbackId);
        return this;
    }

    /**
     * The playback ID associated with the metric.
     */
    public ViewershipMetric withPlaybackId(Optional<? extends String> playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    /**
     * The ID of the creator associated with the metric.
     */
    public ViewershipMetric withCreatorId(String creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = Optional.ofNullable(creatorId);
        return this;
    }

    /**
     * The ID of the creator associated with the metric.
     */
    public ViewershipMetric withCreatorId(Optional<? extends String> creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = creatorId;
        return this;
    }

    /**
     * The ID of the viewer associated with the metric.
     */
    public ViewershipMetric withViewerId(String viewerId) {
        Utils.checkNotNull(viewerId, "viewerId");
        this.viewerId = Optional.ofNullable(viewerId);
        return this;
    }

    /**
     * The ID of the viewer associated with the metric.
     */
    public ViewershipMetric withViewerId(Optional<? extends String> viewerId) {
        Utils.checkNotNull(viewerId, "viewerId");
        this.viewerId = viewerId;
        return this;
    }

    /**
     * The URL of the distributed storage used for the asset
     */
    public ViewershipMetric withDStorageUrl(String dStorageUrl) {
        Utils.checkNotNull(dStorageUrl, "dStorageUrl");
        this.dStorageUrl = Optional.ofNullable(dStorageUrl);
        return this;
    }

    /**
     * The URL of the distributed storage used for the asset
     */
    public ViewershipMetric withDStorageUrl(Optional<? extends String> dStorageUrl) {
        Utils.checkNotNull(dStorageUrl, "dStorageUrl");
        this.dStorageUrl = dStorageUrl;
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    public ViewershipMetric withTimestamp(double timestamp) {
        Utils.checkNotNull(timestamp, "timestamp");
        this.timestamp = Optional.ofNullable(timestamp);
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the metric was recorded. If the
     * query contains a time step, this timestamp will point to the
     * beginning of the time step period.
     * 
     */
    public ViewershipMetric withTimestamp(Optional<? extends Double> timestamp) {
        Utils.checkNotNull(timestamp, "timestamp");
        this.timestamp = timestamp;
        return this;
    }

    /**
     * The device used by the viewer.
     */
    public ViewershipMetric withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }

    /**
     * The device used by the viewer.
     */
    public ViewershipMetric withDevice(Optional<? extends String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * The type of the device used by the viewer.
     */
    public ViewershipMetric withDeviceType(String deviceType) {
        Utils.checkNotNull(deviceType, "deviceType");
        this.deviceType = Optional.ofNullable(deviceType);
        return this;
    }

    /**
     * The type of the device used by the viewer.
     */
    public ViewershipMetric withDeviceType(Optional<? extends String> deviceType) {
        Utils.checkNotNull(deviceType, "deviceType");
        this.deviceType = deviceType;
        return this;
    }

    /**
     * The CPU used by the viewer's device.
     */
    public ViewershipMetric withCpu(String cpu) {
        Utils.checkNotNull(cpu, "cpu");
        this.cpu = Optional.ofNullable(cpu);
        return this;
    }

    /**
     * The CPU used by the viewer's device.
     */
    public ViewershipMetric withCpu(Optional<? extends String> cpu) {
        Utils.checkNotNull(cpu, "cpu");
        this.cpu = cpu;
        return this;
    }

    /**
     * The operating system used by the viewer.
     */
    public ViewershipMetric withOs(String os) {
        Utils.checkNotNull(os, "os");
        this.os = Optional.ofNullable(os);
        return this;
    }

    /**
     * The operating system used by the viewer.
     */
    public ViewershipMetric withOs(Optional<? extends String> os) {
        Utils.checkNotNull(os, "os");
        this.os = os;
        return this;
    }

    /**
     * The browser used by the viewer.
     */
    public ViewershipMetric withBrowser(String browser) {
        Utils.checkNotNull(browser, "browser");
        this.browser = Optional.ofNullable(browser);
        return this;
    }

    /**
     * The browser used by the viewer.
     */
    public ViewershipMetric withBrowser(Optional<? extends String> browser) {
        Utils.checkNotNull(browser, "browser");
        this.browser = browser;
        return this;
    }

    /**
     * The browser engine used by the viewer's browser.
     */
    public ViewershipMetric withBrowserEngine(String browserEngine) {
        Utils.checkNotNull(browserEngine, "browserEngine");
        this.browserEngine = Optional.ofNullable(browserEngine);
        return this;
    }

    /**
     * The browser engine used by the viewer's browser.
     */
    public ViewershipMetric withBrowserEngine(Optional<? extends String> browserEngine) {
        Utils.checkNotNull(browserEngine, "browserEngine");
        this.browserEngine = browserEngine;
        return this;
    }

    /**
     * The continent where the viewer is located.
     */
    public ViewershipMetric withContinent(String continent) {
        Utils.checkNotNull(continent, "continent");
        this.continent = Optional.ofNullable(continent);
        return this;
    }

    /**
     * The continent where the viewer is located.
     */
    public ViewershipMetric withContinent(Optional<? extends String> continent) {
        Utils.checkNotNull(continent, "continent");
        this.continent = continent;
        return this;
    }

    /**
     * The country where the viewer is located.
     */
    public ViewershipMetric withCountry(String country) {
        Utils.checkNotNull(country, "country");
        this.country = Optional.ofNullable(country);
        return this;
    }

    /**
     * The country where the viewer is located.
     */
    public ViewershipMetric withCountry(Optional<? extends String> country) {
        Utils.checkNotNull(country, "country");
        this.country = country;
        return this;
    }

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    public ViewershipMetric withSubdivision(String subdivision) {
        Utils.checkNotNull(subdivision, "subdivision");
        this.subdivision = Optional.ofNullable(subdivision);
        return this;
    }

    /**
     * The subdivision (e.g., state or province) where the viewer is
     * located.
     * 
     */
    public ViewershipMetric withSubdivision(Optional<? extends String> subdivision) {
        Utils.checkNotNull(subdivision, "subdivision");
        this.subdivision = subdivision;
        return this;
    }

    /**
     * The timezone where the viewer is located.
     */
    public ViewershipMetric withTimezone(String timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = Optional.ofNullable(timezone);
        return this;
    }

    /**
     * The timezone where the viewer is located.
     */
    public ViewershipMetric withTimezone(Optional<? extends String> timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = timezone;
        return this;
    }

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    public ViewershipMetric withGeohash(String geohash) {
        Utils.checkNotNull(geohash, "geohash");
        this.geohash = Optional.ofNullable(geohash);
        return this;
    }

    /**
     * Geographic encoding of the viewers location. Accurate to 3 digits.
     */
    public ViewershipMetric withGeohash(Optional<? extends String> geohash) {
        Utils.checkNotNull(geohash, "geohash");
        this.geohash = geohash;
        return this;
    }

    /**
     * The number of views for the asset.
     */
    public ViewershipMetric withViewCount(long viewCount) {
        Utils.checkNotNull(viewCount, "viewCount");
        this.viewCount = viewCount;
        return this;
    }

    /**
     * The total playtime in minutes for the asset.
     */
    public ViewershipMetric withPlaytimeMins(double playtimeMins) {
        Utils.checkNotNull(playtimeMins, "playtimeMins");
        this.playtimeMins = playtimeMins;
        return this;
    }

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    public ViewershipMetric withTtffMs(double ttffMs) {
        Utils.checkNotNull(ttffMs, "ttffMs");
        this.ttffMs = Optional.ofNullable(ttffMs);
        return this;
    }

    /**
     * The time-to-first-frame (TTFF) in milliseconds.
     */
    public ViewershipMetric withTtffMs(Optional<? extends Double> ttffMs) {
        Utils.checkNotNull(ttffMs, "ttffMs");
        this.ttffMs = ttffMs;
        return this;
    }

    /**
     * The rebuffering ratio for the asset.
     */
    public ViewershipMetric withRebufferRatio(double rebufferRatio) {
        Utils.checkNotNull(rebufferRatio, "rebufferRatio");
        this.rebufferRatio = Optional.ofNullable(rebufferRatio);
        return this;
    }

    /**
     * The rebuffering ratio for the asset.
     */
    public ViewershipMetric withRebufferRatio(Optional<? extends Double> rebufferRatio) {
        Utils.checkNotNull(rebufferRatio, "rebufferRatio");
        this.rebufferRatio = rebufferRatio;
        return this;
    }

    /**
     * The error rate for the asset.
     */
    public ViewershipMetric withErrorRate(double errorRate) {
        Utils.checkNotNull(errorRate, "errorRate");
        this.errorRate = Optional.ofNullable(errorRate);
        return this;
    }

    /**
     * The error rate for the asset.
     */
    public ViewershipMetric withErrorRate(Optional<? extends Double> errorRate) {
        Utils.checkNotNull(errorRate, "errorRate");
        this.errorRate = errorRate;
        return this;
    }

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    public ViewershipMetric withExitsBeforeStart(double exitsBeforeStart) {
        Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
        this.exitsBeforeStart = Optional.ofNullable(exitsBeforeStart);
        return this;
    }

    /**
     * The percentage of sessions that existed before the asset started
     * playing.
     * 
     */
    public ViewershipMetric withExitsBeforeStart(Optional<? extends Double> exitsBeforeStart) {
        Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
        this.exitsBeforeStart = exitsBeforeStart;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ViewershipMetric other = (ViewershipMetric) o;
        return 
            java.util.Objects.deepEquals(this.playbackId, other.playbackId) &&
            java.util.Objects.deepEquals(this.creatorId, other.creatorId) &&
            java.util.Objects.deepEquals(this.viewerId, other.viewerId) &&
            java.util.Objects.deepEquals(this.dStorageUrl, other.dStorageUrl) &&
            java.util.Objects.deepEquals(this.timestamp, other.timestamp) &&
            java.util.Objects.deepEquals(this.device, other.device) &&
            java.util.Objects.deepEquals(this.deviceType, other.deviceType) &&
            java.util.Objects.deepEquals(this.cpu, other.cpu) &&
            java.util.Objects.deepEquals(this.os, other.os) &&
            java.util.Objects.deepEquals(this.browser, other.browser) &&
            java.util.Objects.deepEquals(this.browserEngine, other.browserEngine) &&
            java.util.Objects.deepEquals(this.continent, other.continent) &&
            java.util.Objects.deepEquals(this.country, other.country) &&
            java.util.Objects.deepEquals(this.subdivision, other.subdivision) &&
            java.util.Objects.deepEquals(this.timezone, other.timezone) &&
            java.util.Objects.deepEquals(this.geohash, other.geohash) &&
            java.util.Objects.deepEquals(this.viewCount, other.viewCount) &&
            java.util.Objects.deepEquals(this.playtimeMins, other.playtimeMins) &&
            java.util.Objects.deepEquals(this.ttffMs, other.ttffMs) &&
            java.util.Objects.deepEquals(this.rebufferRatio, other.rebufferRatio) &&
            java.util.Objects.deepEquals(this.errorRate, other.errorRate) &&
            java.util.Objects.deepEquals(this.exitsBeforeStart, other.exitsBeforeStart);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            playbackId,
            creatorId,
            viewerId,
            dStorageUrl,
            timestamp,
            device,
            deviceType,
            cpu,
            os,
            browser,
            browserEngine,
            continent,
            country,
            subdivision,
            timezone,
            geohash,
            viewCount,
            playtimeMins,
            ttffMs,
            rebufferRatio,
            errorRate,
            exitsBeforeStart);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ViewershipMetric.class,
                "playbackId", playbackId,
                "creatorId", creatorId,
                "viewerId", viewerId,
                "dStorageUrl", dStorageUrl,
                "timestamp", timestamp,
                "device", device,
                "deviceType", deviceType,
                "cpu", cpu,
                "os", os,
                "browser", browser,
                "browserEngine", browserEngine,
                "continent", continent,
                "country", country,
                "subdivision", subdivision,
                "timezone", timezone,
                "geohash", geohash,
                "viewCount", viewCount,
                "playtimeMins", playtimeMins,
                "ttffMs", ttffMs,
                "rebufferRatio", rebufferRatio,
                "errorRate", errorRate,
                "exitsBeforeStart", exitsBeforeStart);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> playbackId = Optional.empty();
 
        private Optional<? extends String> creatorId = Optional.empty();
 
        private Optional<? extends String> viewerId = Optional.empty();
 
        private Optional<? extends String> dStorageUrl = Optional.empty();
 
        private Optional<? extends Double> timestamp = Optional.empty();
 
        private Optional<? extends String> device = Optional.empty();
 
        private Optional<? extends String> deviceType = Optional.empty();
 
        private Optional<? extends String> cpu = Optional.empty();
 
        private Optional<? extends String> os = Optional.empty();
 
        private Optional<? extends String> browser = Optional.empty();
 
        private Optional<? extends String> browserEngine = Optional.empty();
 
        private Optional<? extends String> continent = Optional.empty();
 
        private Optional<? extends String> country = Optional.empty();
 
        private Optional<? extends String> subdivision = Optional.empty();
 
        private Optional<? extends String> timezone = Optional.empty();
 
        private Optional<? extends String> geohash = Optional.empty();
 
        private Long viewCount;
 
        private Double playtimeMins;
 
        private Optional<? extends Double> ttffMs = Optional.empty();
 
        private Optional<? extends Double> rebufferRatio = Optional.empty();
 
        private Optional<? extends Double> errorRate = Optional.empty();
 
        private Optional<? extends Double> exitsBeforeStart = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The playback ID associated with the metric.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = Optional.ofNullable(playbackId);
            return this;
        }

        /**
         * The playback ID associated with the metric.
         */
        public Builder playbackId(Optional<? extends String> playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        /**
         * The ID of the creator associated with the metric.
         */
        public Builder creatorId(String creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = Optional.ofNullable(creatorId);
            return this;
        }

        /**
         * The ID of the creator associated with the metric.
         */
        public Builder creatorId(Optional<? extends String> creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = creatorId;
            return this;
        }

        /**
         * The ID of the viewer associated with the metric.
         */
        public Builder viewerId(String viewerId) {
            Utils.checkNotNull(viewerId, "viewerId");
            this.viewerId = Optional.ofNullable(viewerId);
            return this;
        }

        /**
         * The ID of the viewer associated with the metric.
         */
        public Builder viewerId(Optional<? extends String> viewerId) {
            Utils.checkNotNull(viewerId, "viewerId");
            this.viewerId = viewerId;
            return this;
        }

        /**
         * The URL of the distributed storage used for the asset
         */
        public Builder dStorageUrl(String dStorageUrl) {
            Utils.checkNotNull(dStorageUrl, "dStorageUrl");
            this.dStorageUrl = Optional.ofNullable(dStorageUrl);
            return this;
        }

        /**
         * The URL of the distributed storage used for the asset
         */
        public Builder dStorageUrl(Optional<? extends String> dStorageUrl) {
            Utils.checkNotNull(dStorageUrl, "dStorageUrl");
            this.dStorageUrl = dStorageUrl;
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the metric was recorded. If the
         * query contains a time step, this timestamp will point to the
         * beginning of the time step period.
         * 
         */
        public Builder timestamp(double timestamp) {
            Utils.checkNotNull(timestamp, "timestamp");
            this.timestamp = Optional.ofNullable(timestamp);
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the metric was recorded. If the
         * query contains a time step, this timestamp will point to the
         * beginning of the time step period.
         * 
         */
        public Builder timestamp(Optional<? extends Double> timestamp) {
            Utils.checkNotNull(timestamp, "timestamp");
            this.timestamp = timestamp;
            return this;
        }

        /**
         * The device used by the viewer.
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * The device used by the viewer.
         */
        public Builder device(Optional<? extends String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }

        /**
         * The type of the device used by the viewer.
         */
        public Builder deviceType(String deviceType) {
            Utils.checkNotNull(deviceType, "deviceType");
            this.deviceType = Optional.ofNullable(deviceType);
            return this;
        }

        /**
         * The type of the device used by the viewer.
         */
        public Builder deviceType(Optional<? extends String> deviceType) {
            Utils.checkNotNull(deviceType, "deviceType");
            this.deviceType = deviceType;
            return this;
        }

        /**
         * The CPU used by the viewer's device.
         */
        public Builder cpu(String cpu) {
            Utils.checkNotNull(cpu, "cpu");
            this.cpu = Optional.ofNullable(cpu);
            return this;
        }

        /**
         * The CPU used by the viewer's device.
         */
        public Builder cpu(Optional<? extends String> cpu) {
            Utils.checkNotNull(cpu, "cpu");
            this.cpu = cpu;
            return this;
        }

        /**
         * The operating system used by the viewer.
         */
        public Builder os(String os) {
            Utils.checkNotNull(os, "os");
            this.os = Optional.ofNullable(os);
            return this;
        }

        /**
         * The operating system used by the viewer.
         */
        public Builder os(Optional<? extends String> os) {
            Utils.checkNotNull(os, "os");
            this.os = os;
            return this;
        }

        /**
         * The browser used by the viewer.
         */
        public Builder browser(String browser) {
            Utils.checkNotNull(browser, "browser");
            this.browser = Optional.ofNullable(browser);
            return this;
        }

        /**
         * The browser used by the viewer.
         */
        public Builder browser(Optional<? extends String> browser) {
            Utils.checkNotNull(browser, "browser");
            this.browser = browser;
            return this;
        }

        /**
         * The browser engine used by the viewer's browser.
         */
        public Builder browserEngine(String browserEngine) {
            Utils.checkNotNull(browserEngine, "browserEngine");
            this.browserEngine = Optional.ofNullable(browserEngine);
            return this;
        }

        /**
         * The browser engine used by the viewer's browser.
         */
        public Builder browserEngine(Optional<? extends String> browserEngine) {
            Utils.checkNotNull(browserEngine, "browserEngine");
            this.browserEngine = browserEngine;
            return this;
        }

        /**
         * The continent where the viewer is located.
         */
        public Builder continent(String continent) {
            Utils.checkNotNull(continent, "continent");
            this.continent = Optional.ofNullable(continent);
            return this;
        }

        /**
         * The continent where the viewer is located.
         */
        public Builder continent(Optional<? extends String> continent) {
            Utils.checkNotNull(continent, "continent");
            this.continent = continent;
            return this;
        }

        /**
         * The country where the viewer is located.
         */
        public Builder country(String country) {
            Utils.checkNotNull(country, "country");
            this.country = Optional.ofNullable(country);
            return this;
        }

        /**
         * The country where the viewer is located.
         */
        public Builder country(Optional<? extends String> country) {
            Utils.checkNotNull(country, "country");
            this.country = country;
            return this;
        }

        /**
         * The subdivision (e.g., state or province) where the viewer is
         * located.
         * 
         */
        public Builder subdivision(String subdivision) {
            Utils.checkNotNull(subdivision, "subdivision");
            this.subdivision = Optional.ofNullable(subdivision);
            return this;
        }

        /**
         * The subdivision (e.g., state or province) where the viewer is
         * located.
         * 
         */
        public Builder subdivision(Optional<? extends String> subdivision) {
            Utils.checkNotNull(subdivision, "subdivision");
            this.subdivision = subdivision;
            return this;
        }

        /**
         * The timezone where the viewer is located.
         */
        public Builder timezone(String timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = Optional.ofNullable(timezone);
            return this;
        }

        /**
         * The timezone where the viewer is located.
         */
        public Builder timezone(Optional<? extends String> timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = timezone;
            return this;
        }

        /**
         * Geographic encoding of the viewers location. Accurate to 3 digits.
         */
        public Builder geohash(String geohash) {
            Utils.checkNotNull(geohash, "geohash");
            this.geohash = Optional.ofNullable(geohash);
            return this;
        }

        /**
         * Geographic encoding of the viewers location. Accurate to 3 digits.
         */
        public Builder geohash(Optional<? extends String> geohash) {
            Utils.checkNotNull(geohash, "geohash");
            this.geohash = geohash;
            return this;
        }

        /**
         * The number of views for the asset.
         */
        public Builder viewCount(long viewCount) {
            Utils.checkNotNull(viewCount, "viewCount");
            this.viewCount = viewCount;
            return this;
        }

        /**
         * The total playtime in minutes for the asset.
         */
        public Builder playtimeMins(double playtimeMins) {
            Utils.checkNotNull(playtimeMins, "playtimeMins");
            this.playtimeMins = playtimeMins;
            return this;
        }

        /**
         * The time-to-first-frame (TTFF) in milliseconds.
         */
        public Builder ttffMs(double ttffMs) {
            Utils.checkNotNull(ttffMs, "ttffMs");
            this.ttffMs = Optional.ofNullable(ttffMs);
            return this;
        }

        /**
         * The time-to-first-frame (TTFF) in milliseconds.
         */
        public Builder ttffMs(Optional<? extends Double> ttffMs) {
            Utils.checkNotNull(ttffMs, "ttffMs");
            this.ttffMs = ttffMs;
            return this;
        }

        /**
         * The rebuffering ratio for the asset.
         */
        public Builder rebufferRatio(double rebufferRatio) {
            Utils.checkNotNull(rebufferRatio, "rebufferRatio");
            this.rebufferRatio = Optional.ofNullable(rebufferRatio);
            return this;
        }

        /**
         * The rebuffering ratio for the asset.
         */
        public Builder rebufferRatio(Optional<? extends Double> rebufferRatio) {
            Utils.checkNotNull(rebufferRatio, "rebufferRatio");
            this.rebufferRatio = rebufferRatio;
            return this;
        }

        /**
         * The error rate for the asset.
         */
        public Builder errorRate(double errorRate) {
            Utils.checkNotNull(errorRate, "errorRate");
            this.errorRate = Optional.ofNullable(errorRate);
            return this;
        }

        /**
         * The error rate for the asset.
         */
        public Builder errorRate(Optional<? extends Double> errorRate) {
            Utils.checkNotNull(errorRate, "errorRate");
            this.errorRate = errorRate;
            return this;
        }

        /**
         * The percentage of sessions that existed before the asset started
         * playing.
         * 
         */
        public Builder exitsBeforeStart(double exitsBeforeStart) {
            Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
            this.exitsBeforeStart = Optional.ofNullable(exitsBeforeStart);
            return this;
        }

        /**
         * The percentage of sessions that existed before the asset started
         * playing.
         * 
         */
        public Builder exitsBeforeStart(Optional<? extends Double> exitsBeforeStart) {
            Utils.checkNotNull(exitsBeforeStart, "exitsBeforeStart");
            this.exitsBeforeStart = exitsBeforeStart;
            return this;
        }
        
        public ViewershipMetric build() {
            return new ViewershipMetric(
                playbackId,
                creatorId,
                viewerId,
                dStorageUrl,
                timestamp,
                device,
                deviceType,
                cpu,
                os,
                browser,
                browserEngine,
                continent,
                country,
                subdivision,
                timezone,
                geohash,
                viewCount,
                playtimeMins,
                ttffMs,
                rebufferRatio,
                errorRate,
                exitsBeforeStart);
        }
    }
}

