/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import studio.livepeer.livepeer.utils.Utils;


public class ClipPayload {

    /**
     * The playback ID of the stream or stream recording to clip. Asset playback IDs are not supported yet.
     */
    @JsonProperty("playbackId")
    private String playbackId;

    /**
     * The start timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    @JsonProperty("startTime")
    private double startTime;

    /**
     * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("endTime")
    private Optional<? extends Double> endTime;

    /**
     * The optional friendly name of the clip to create.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private Optional<? extends String> name;

    /**
     * The optional session ID of the stream to clip. This can be used to clip _recordings_ - if it is not specified, it will clip the ongoing livestream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sessionId")
    private Optional<? extends String> sessionId;

    @JsonCreator
    public ClipPayload(
            @JsonProperty("playbackId") String playbackId,
            @JsonProperty("startTime") double startTime,
            @JsonProperty("endTime") Optional<? extends Double> endTime,
            @JsonProperty("name") Optional<? extends String> name,
            @JsonProperty("sessionId") Optional<? extends String> sessionId) {
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(startTime, "startTime");
        Utils.checkNotNull(endTime, "endTime");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(sessionId, "sessionId");
        this.playbackId = playbackId;
        this.startTime = startTime;
        this.endTime = endTime;
        this.name = name;
        this.sessionId = sessionId;
    }
    
    public ClipPayload(
            String playbackId,
            double startTime) {
        this(playbackId, startTime, Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The playback ID of the stream or stream recording to clip. Asset playback IDs are not supported yet.
     */
    @JsonIgnore
    public String playbackId() {
        return playbackId;
    }

    /**
     * The start timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    @JsonIgnore
    public double startTime() {
        return startTime;
    }

    /**
     * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> endTime() {
        return (Optional<Double>) endTime;
    }

    /**
     * The optional friendly name of the clip to create.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> name() {
        return (Optional<String>) name;
    }

    /**
     * The optional session ID of the stream to clip. This can be used to clip _recordings_ - if it is not specified, it will clip the ongoing livestream.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> sessionId() {
        return (Optional<String>) sessionId;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The playback ID of the stream or stream recording to clip. Asset playback IDs are not supported yet.
     */
    public ClipPayload withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    /**
     * The start timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    public ClipPayload withStartTime(double startTime) {
        Utils.checkNotNull(startTime, "startTime");
        this.startTime = startTime;
        return this;
    }

    /**
     * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    public ClipPayload withEndTime(double endTime) {
        Utils.checkNotNull(endTime, "endTime");
        this.endTime = Optional.ofNullable(endTime);
        return this;
    }

    /**
     * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    public ClipPayload withEndTime(Optional<? extends Double> endTime) {
        Utils.checkNotNull(endTime, "endTime");
        this.endTime = endTime;
        return this;
    }

    /**
     * The optional friendly name of the clip to create.
     */
    public ClipPayload withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = Optional.ofNullable(name);
        return this;
    }

    /**
     * The optional friendly name of the clip to create.
     */
    public ClipPayload withName(Optional<? extends String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * The optional session ID of the stream to clip. This can be used to clip _recordings_ - if it is not specified, it will clip the ongoing livestream.
     */
    public ClipPayload withSessionId(String sessionId) {
        Utils.checkNotNull(sessionId, "sessionId");
        this.sessionId = Optional.ofNullable(sessionId);
        return this;
    }

    /**
     * The optional session ID of the stream to clip. This can be used to clip _recordings_ - if it is not specified, it will clip the ongoing livestream.
     */
    public ClipPayload withSessionId(Optional<? extends String> sessionId) {
        Utils.checkNotNull(sessionId, "sessionId");
        this.sessionId = sessionId;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ClipPayload other = (ClipPayload) o;
        return 
            java.util.Objects.deepEquals(this.playbackId, other.playbackId) &&
            java.util.Objects.deepEquals(this.startTime, other.startTime) &&
            java.util.Objects.deepEquals(this.endTime, other.endTime) &&
            java.util.Objects.deepEquals(this.name, other.name) &&
            java.util.Objects.deepEquals(this.sessionId, other.sessionId);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            playbackId,
            startTime,
            endTime,
            name,
            sessionId);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ClipPayload.class,
                "playbackId", playbackId,
                "startTime", startTime,
                "endTime", endTime,
                "name", name,
                "sessionId", sessionId);
    }
    
    public final static class Builder {
 
        private String playbackId;
 
        private Double startTime;
 
        private Optional<? extends Double> endTime = Optional.empty();
 
        private Optional<? extends String> name = Optional.empty();
 
        private Optional<? extends String> sessionId = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The playback ID of the stream or stream recording to clip. Asset playback IDs are not supported yet.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        /**
         * The start timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
         */
        public Builder startTime(double startTime) {
            Utils.checkNotNull(startTime, "startTime");
            this.startTime = startTime;
            return this;
        }

        /**
         * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
         */
        public Builder endTime(double endTime) {
            Utils.checkNotNull(endTime, "endTime");
            this.endTime = Optional.ofNullable(endTime);
            return this;
        }

        /**
         * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
         */
        public Builder endTime(Optional<? extends Double> endTime) {
            Utils.checkNotNull(endTime, "endTime");
            this.endTime = endTime;
            return this;
        }

        /**
         * The optional friendly name of the clip to create.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * The optional friendly name of the clip to create.
         */
        public Builder name(Optional<? extends String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * The optional session ID of the stream to clip. This can be used to clip _recordings_ - if it is not specified, it will clip the ongoing livestream.
         */
        public Builder sessionId(String sessionId) {
            Utils.checkNotNull(sessionId, "sessionId");
            this.sessionId = Optional.ofNullable(sessionId);
            return this;
        }

        /**
         * The optional session ID of the stream to clip. This can be used to clip _recordings_ - if it is not specified, it will clip the ongoing livestream.
         */
        public Builder sessionId(Optional<? extends String> sessionId) {
            Utils.checkNotNull(sessionId, "sessionId");
            this.sessionId = sessionId;
            return this;
        }
        
        public ClipPayload build() {
            return new ClipPayload(
                playbackId,
                startTime,
                endTime,
                name,
                sessionId);
        }
    }
}

