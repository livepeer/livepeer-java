/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Deprecated;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
import studio.livepeer.livepeer.utils.Utils;


public class Stream {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    @JsonProperty("name")
    private String name;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kind")
    @Deprecated
    private Optional<String> kind;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private Optional<? extends CreatorId> creatorId;

    /**
     * User input tags associated with the stream
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userTags")
    private Optional<? extends Map<String, StreamUserTags>> userTags;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastSeen")
    private Optional<Double> lastSeen;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegments")
    private Optional<Double> sourceSegments;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegments")
    private Optional<Double> transcodedSegments;

    /**
     * Duration of all the source segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegmentsDuration")
    private Optional<Double> sourceSegmentsDuration;

    /**
     * Duration of all the transcoded segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegmentsDuration")
    private Optional<Double> transcodedSegmentsDuration;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceBytes")
    private Optional<Double> sourceBytes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedBytes")
    private Optional<Double> transcodedBytes;

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ingestRate")
    private Optional<Double> ingestRate;

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("outgoingRate")
    private Optional<Double> outgoingRate;

    /**
     * If currently active
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isActive")
    private Optional<Boolean> isActive;

    /**
     * Indicates whether the stream is healthy or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isHealthy")
    private JsonNullable<Boolean> isHealthy;

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issues")
    private JsonNullable<? extends List<String>> issues;

    /**
     * Name of the token used to create this object
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdByTokenName")
    private Optional<String> createdByTokenName;

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<Double> createdAt;

    /**
     * Points to parent stream object
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentId")
    private Optional<String> parentId;

    /**
     * Used to form RTMP ingest URL
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("streamKey")
    private Optional<String> streamKey;

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pull")
    private Optional<? extends StreamPull> pull;

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackId")
    private Optional<String> playbackId;

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackPolicy")
    private JsonNullable<? extends PlaybackPolicy> playbackPolicy;

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profiles")
    private Optional<? extends List<FfmpegProfile>> profiles;

    /**
     * The ID of the project
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("projectId")
    private Optional<String> projectId;

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("record")
    private Optional<Boolean> record;

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingSpec")
    private Optional<? extends StreamRecordingSpec> recordingSpec;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("multistream")
    private Optional<? extends StreamMultistream> multistream;

    /**
     * If currently suspended
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("suspended")
    private Optional<Boolean> suspended;

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastTerminatedAt")
    private JsonNullable<Double> lastTerminatedAt;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userId")
    @Deprecated
    private Optional<String> userId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("renditions")
    private Optional<? extends Renditions> renditions;

    @JsonCreator
    public Stream(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("name") String name,
            @JsonProperty("kind") Optional<String> kind,
            @JsonProperty("creatorId") Optional<? extends CreatorId> creatorId,
            @JsonProperty("userTags") Optional<? extends Map<String, StreamUserTags>> userTags,
            @JsonProperty("lastSeen") Optional<Double> lastSeen,
            @JsonProperty("sourceSegments") Optional<Double> sourceSegments,
            @JsonProperty("transcodedSegments") Optional<Double> transcodedSegments,
            @JsonProperty("sourceSegmentsDuration") Optional<Double> sourceSegmentsDuration,
            @JsonProperty("transcodedSegmentsDuration") Optional<Double> transcodedSegmentsDuration,
            @JsonProperty("sourceBytes") Optional<Double> sourceBytes,
            @JsonProperty("transcodedBytes") Optional<Double> transcodedBytes,
            @JsonProperty("ingestRate") Optional<Double> ingestRate,
            @JsonProperty("outgoingRate") Optional<Double> outgoingRate,
            @JsonProperty("isActive") Optional<Boolean> isActive,
            @JsonProperty("isHealthy") JsonNullable<Boolean> isHealthy,
            @JsonProperty("issues") JsonNullable<? extends List<String>> issues,
            @JsonProperty("createdByTokenName") Optional<String> createdByTokenName,
            @JsonProperty("createdAt") Optional<Double> createdAt,
            @JsonProperty("parentId") Optional<String> parentId,
            @JsonProperty("streamKey") Optional<String> streamKey,
            @JsonProperty("pull") Optional<? extends StreamPull> pull,
            @JsonProperty("playbackId") Optional<String> playbackId,
            @JsonProperty("playbackPolicy") JsonNullable<? extends PlaybackPolicy> playbackPolicy,
            @JsonProperty("profiles") Optional<? extends List<FfmpegProfile>> profiles,
            @JsonProperty("projectId") Optional<String> projectId,
            @JsonProperty("record") Optional<Boolean> record,
            @JsonProperty("recordingSpec") Optional<? extends StreamRecordingSpec> recordingSpec,
            @JsonProperty("multistream") Optional<? extends StreamMultistream> multistream,
            @JsonProperty("suspended") Optional<Boolean> suspended,
            @JsonProperty("lastTerminatedAt") JsonNullable<Double> lastTerminatedAt,
            @JsonProperty("userId") Optional<String> userId,
            @JsonProperty("renditions") Optional<? extends Renditions> renditions) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(kind, "kind");
        Utils.checkNotNull(creatorId, "creatorId");
        Utils.checkNotNull(userTags, "userTags");
        Utils.checkNotNull(lastSeen, "lastSeen");
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        Utils.checkNotNull(ingestRate, "ingestRate");
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        Utils.checkNotNull(isActive, "isActive");
        Utils.checkNotNull(isHealthy, "isHealthy");
        Utils.checkNotNull(issues, "issues");
        Utils.checkNotNull(createdByTokenName, "createdByTokenName");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(parentId, "parentId");
        Utils.checkNotNull(streamKey, "streamKey");
        Utils.checkNotNull(pull, "pull");
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        Utils.checkNotNull(profiles, "profiles");
        Utils.checkNotNull(projectId, "projectId");
        Utils.checkNotNull(record, "record");
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        Utils.checkNotNull(multistream, "multistream");
        Utils.checkNotNull(suspended, "suspended");
        Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
        Utils.checkNotNull(userId, "userId");
        Utils.checkNotNull(renditions, "renditions");
        this.id = id;
        this.name = name;
        this.kind = kind;
        this.creatorId = creatorId;
        this.userTags = userTags;
        this.lastSeen = lastSeen;
        this.sourceSegments = sourceSegments;
        this.transcodedSegments = transcodedSegments;
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        this.sourceBytes = sourceBytes;
        this.transcodedBytes = transcodedBytes;
        this.ingestRate = ingestRate;
        this.outgoingRate = outgoingRate;
        this.isActive = isActive;
        this.isHealthy = isHealthy;
        this.issues = issues;
        this.createdByTokenName = createdByTokenName;
        this.createdAt = createdAt;
        this.parentId = parentId;
        this.streamKey = streamKey;
        this.pull = pull;
        this.playbackId = playbackId;
        this.playbackPolicy = playbackPolicy;
        this.profiles = profiles;
        this.projectId = projectId;
        this.record = record;
        this.recordingSpec = recordingSpec;
        this.multistream = multistream;
        this.suspended = suspended;
        this.lastTerminatedAt = lastTerminatedAt;
        this.userId = userId;
        this.renditions = renditions;
    }
    
    public Stream(
            String name) {
        this(Optional.empty(), name, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @JsonIgnore
    public Optional<String> kind() {
        return kind;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreatorId> creatorId() {
        return (Optional<CreatorId>) creatorId;
    }

    /**
     * User input tags associated with the stream
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, StreamUserTags>> userTags() {
        return (Optional<Map<String, StreamUserTags>>) userTags;
    }

    @JsonIgnore
    public Optional<Double> lastSeen() {
        return lastSeen;
    }

    @JsonIgnore
    public Optional<Double> sourceSegments() {
        return sourceSegments;
    }

    @JsonIgnore
    public Optional<Double> transcodedSegments() {
        return transcodedSegments;
    }

    /**
     * Duration of all the source segments, sec
     */
    @JsonIgnore
    public Optional<Double> sourceSegmentsDuration() {
        return sourceSegmentsDuration;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    @JsonIgnore
    public Optional<Double> transcodedSegmentsDuration() {
        return transcodedSegmentsDuration;
    }

    @JsonIgnore
    public Optional<Double> sourceBytes() {
        return sourceBytes;
    }

    @JsonIgnore
    public Optional<Double> transcodedBytes() {
        return transcodedBytes;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @JsonIgnore
    public Optional<Double> ingestRate() {
        return ingestRate;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @JsonIgnore
    public Optional<Double> outgoingRate() {
        return outgoingRate;
    }

    /**
     * If currently active
     */
    @JsonIgnore
    public Optional<Boolean> isActive() {
        return isActive;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isHealthy() {
        return isHealthy;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<String>> issues() {
        return (JsonNullable<List<String>>) issues;
    }

    /**
     * Name of the token used to create this object
     */
    @JsonIgnore
    public Optional<String> createdByTokenName() {
        return createdByTokenName;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @JsonIgnore
    public Optional<Double> createdAt() {
        return createdAt;
    }

    /**
     * Points to parent stream object
     */
    @JsonIgnore
    public Optional<String> parentId() {
        return parentId;
    }

    /**
     * Used to form RTMP ingest URL
     */
    @JsonIgnore
    public Optional<String> streamKey() {
        return streamKey;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StreamPull> pull() {
        return (Optional<StreamPull>) pull;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @JsonIgnore
    public Optional<String> playbackId() {
        return playbackId;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PlaybackPolicy> playbackPolicy() {
        return (JsonNullable<PlaybackPolicy>) playbackPolicy;
    }

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FfmpegProfile>> profiles() {
        return (Optional<List<FfmpegProfile>>) profiles;
    }

    /**
     * The ID of the project
     */
    @JsonIgnore
    public Optional<String> projectId() {
        return projectId;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonIgnore
    public Optional<Boolean> record() {
        return record;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StreamRecordingSpec> recordingSpec() {
        return (Optional<StreamRecordingSpec>) recordingSpec;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StreamMultistream> multistream() {
        return (Optional<StreamMultistream>) multistream;
    }

    /**
     * If currently suspended
     */
    @JsonIgnore
    public Optional<Boolean> suspended() {
        return suspended;
    }

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    @JsonIgnore
    public JsonNullable<Double> lastTerminatedAt() {
        return lastTerminatedAt;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @JsonIgnore
    public Optional<String> userId() {
        return userId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Renditions> renditions() {
        return (Optional<Renditions>) renditions;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public Stream withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    public Stream withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public Stream withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withKind(String kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = Optional.ofNullable(kind);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withKind(Optional<String> kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = kind;
        return this;
    }

    public Stream withCreatorId(CreatorId creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = Optional.ofNullable(creatorId);
        return this;
    }

    public Stream withCreatorId(Optional<? extends CreatorId> creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = creatorId;
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public Stream withUserTags(Map<String, StreamUserTags> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = Optional.ofNullable(userTags);
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public Stream withUserTags(Optional<? extends Map<String, StreamUserTags>> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = userTags;
        return this;
    }

    public Stream withLastSeen(double lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = Optional.ofNullable(lastSeen);
        return this;
    }

    public Stream withLastSeen(Optional<Double> lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = lastSeen;
        return this;
    }

    public Stream withSourceSegments(double sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = Optional.ofNullable(sourceSegments);
        return this;
    }

    public Stream withSourceSegments(Optional<Double> sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = sourceSegments;
        return this;
    }

    public Stream withTranscodedSegments(double transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = Optional.ofNullable(transcodedSegments);
        return this;
    }

    public Stream withTranscodedSegments(Optional<Double> transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = transcodedSegments;
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Stream withSourceSegmentsDuration(double sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Stream withSourceSegmentsDuration(Optional<Double> sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Stream withTranscodedSegmentsDuration(double transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Stream withTranscodedSegmentsDuration(Optional<Double> transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        return this;
    }

    public Stream withSourceBytes(double sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = Optional.ofNullable(sourceBytes);
        return this;
    }

    public Stream withSourceBytes(Optional<Double> sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = sourceBytes;
        return this;
    }

    public Stream withTranscodedBytes(double transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = Optional.ofNullable(transcodedBytes);
        return this;
    }

    public Stream withTranscodedBytes(Optional<Double> transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = transcodedBytes;
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Stream withIngestRate(double ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = Optional.ofNullable(ingestRate);
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Stream withIngestRate(Optional<Double> ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = ingestRate;
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Stream withOutgoingRate(double outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = Optional.ofNullable(outgoingRate);
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Stream withOutgoingRate(Optional<Double> outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = outgoingRate;
        return this;
    }

    /**
     * If currently active
     */
    public Stream withIsActive(boolean isActive) {
        Utils.checkNotNull(isActive, "isActive");
        this.isActive = Optional.ofNullable(isActive);
        return this;
    }

    /**
     * If currently active
     */
    public Stream withIsActive(Optional<Boolean> isActive) {
        Utils.checkNotNull(isActive, "isActive");
        this.isActive = isActive;
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Stream withIsHealthy(boolean isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = JsonNullable.of(isHealthy);
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Stream withIsHealthy(JsonNullable<Boolean> isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = isHealthy;
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Stream withIssues(List<String> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = JsonNullable.of(issues);
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Stream withIssues(JsonNullable<? extends List<String>> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = issues;
        return this;
    }

    /**
     * Name of the token used to create this object
     */
    public Stream withCreatedByTokenName(String createdByTokenName) {
        Utils.checkNotNull(createdByTokenName, "createdByTokenName");
        this.createdByTokenName = Optional.ofNullable(createdByTokenName);
        return this;
    }

    /**
     * Name of the token used to create this object
     */
    public Stream withCreatedByTokenName(Optional<String> createdByTokenName) {
        Utils.checkNotNull(createdByTokenName, "createdByTokenName");
        this.createdByTokenName = createdByTokenName;
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Stream withCreatedAt(double createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Stream withCreatedAt(Optional<Double> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Stream withParentId(String parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = Optional.ofNullable(parentId);
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Stream withParentId(Optional<String> parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = parentId;
        return this;
    }

    /**
     * Used to form RTMP ingest URL
     */
    public Stream withStreamKey(String streamKey) {
        Utils.checkNotNull(streamKey, "streamKey");
        this.streamKey = Optional.ofNullable(streamKey);
        return this;
    }

    /**
     * Used to form RTMP ingest URL
     */
    public Stream withStreamKey(Optional<String> streamKey) {
        Utils.checkNotNull(streamKey, "streamKey");
        this.streamKey = streamKey;
        return this;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    public Stream withPull(StreamPull pull) {
        Utils.checkNotNull(pull, "pull");
        this.pull = Optional.ofNullable(pull);
        return this;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    public Stream withPull(Optional<? extends StreamPull> pull) {
        Utils.checkNotNull(pull, "pull");
        this.pull = pull;
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Stream withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = Optional.ofNullable(playbackId);
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Stream withPlaybackId(Optional<String> playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public Stream withPlaybackPolicy(PlaybackPolicy playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = JsonNullable.of(playbackPolicy);
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public Stream withPlaybackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = playbackPolicy;
        return this;
    }

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    public Stream withProfiles(List<FfmpegProfile> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = Optional.ofNullable(profiles);
        return this;
    }

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    public Stream withProfiles(Optional<? extends List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = profiles;
        return this;
    }

    /**
     * The ID of the project
     */
    public Stream withProjectId(String projectId) {
        Utils.checkNotNull(projectId, "projectId");
        this.projectId = Optional.ofNullable(projectId);
        return this;
    }

    /**
     * The ID of the project
     */
    public Stream withProjectId(Optional<String> projectId) {
        Utils.checkNotNull(projectId, "projectId");
        this.projectId = projectId;
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public Stream withRecord(boolean record) {
        Utils.checkNotNull(record, "record");
        this.record = Optional.ofNullable(record);
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public Stream withRecord(Optional<Boolean> record) {
        Utils.checkNotNull(record, "record");
        this.record = record;
        return this;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    public Stream withRecordingSpec(StreamRecordingSpec recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = Optional.ofNullable(recordingSpec);
        return this;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    public Stream withRecordingSpec(Optional<? extends StreamRecordingSpec> recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = recordingSpec;
        return this;
    }

    public Stream withMultistream(StreamMultistream multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = Optional.ofNullable(multistream);
        return this;
    }

    public Stream withMultistream(Optional<? extends StreamMultistream> multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = multistream;
        return this;
    }

    /**
     * If currently suspended
     */
    public Stream withSuspended(boolean suspended) {
        Utils.checkNotNull(suspended, "suspended");
        this.suspended = Optional.ofNullable(suspended);
        return this;
    }

    /**
     * If currently suspended
     */
    public Stream withSuspended(Optional<Boolean> suspended) {
        Utils.checkNotNull(suspended, "suspended");
        this.suspended = suspended;
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    public Stream withLastTerminatedAt(double lastTerminatedAt) {
        Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
        this.lastTerminatedAt = JsonNullable.of(lastTerminatedAt);
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    public Stream withLastTerminatedAt(JsonNullable<Double> lastTerminatedAt) {
        Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
        this.lastTerminatedAt = lastTerminatedAt;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withUserId(String userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = Optional.ofNullable(userId);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withUserId(Optional<String> userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = userId;
        return this;
    }

    public Stream withRenditions(Renditions renditions) {
        Utils.checkNotNull(renditions, "renditions");
        this.renditions = Optional.ofNullable(renditions);
        return this;
    }

    public Stream withRenditions(Optional<? extends Renditions> renditions) {
        Utils.checkNotNull(renditions, "renditions");
        this.renditions = renditions;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Stream other = (Stream) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.kind, other.kind) &&
            Objects.deepEquals(this.creatorId, other.creatorId) &&
            Objects.deepEquals(this.userTags, other.userTags) &&
            Objects.deepEquals(this.lastSeen, other.lastSeen) &&
            Objects.deepEquals(this.sourceSegments, other.sourceSegments) &&
            Objects.deepEquals(this.transcodedSegments, other.transcodedSegments) &&
            Objects.deepEquals(this.sourceSegmentsDuration, other.sourceSegmentsDuration) &&
            Objects.deepEquals(this.transcodedSegmentsDuration, other.transcodedSegmentsDuration) &&
            Objects.deepEquals(this.sourceBytes, other.sourceBytes) &&
            Objects.deepEquals(this.transcodedBytes, other.transcodedBytes) &&
            Objects.deepEquals(this.ingestRate, other.ingestRate) &&
            Objects.deepEquals(this.outgoingRate, other.outgoingRate) &&
            Objects.deepEquals(this.isActive, other.isActive) &&
            Objects.deepEquals(this.isHealthy, other.isHealthy) &&
            Objects.deepEquals(this.issues, other.issues) &&
            Objects.deepEquals(this.createdByTokenName, other.createdByTokenName) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.parentId, other.parentId) &&
            Objects.deepEquals(this.streamKey, other.streamKey) &&
            Objects.deepEquals(this.pull, other.pull) &&
            Objects.deepEquals(this.playbackId, other.playbackId) &&
            Objects.deepEquals(this.playbackPolicy, other.playbackPolicy) &&
            Objects.deepEquals(this.profiles, other.profiles) &&
            Objects.deepEquals(this.projectId, other.projectId) &&
            Objects.deepEquals(this.record, other.record) &&
            Objects.deepEquals(this.recordingSpec, other.recordingSpec) &&
            Objects.deepEquals(this.multistream, other.multistream) &&
            Objects.deepEquals(this.suspended, other.suspended) &&
            Objects.deepEquals(this.lastTerminatedAt, other.lastTerminatedAt) &&
            Objects.deepEquals(this.userId, other.userId) &&
            Objects.deepEquals(this.renditions, other.renditions);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            name,
            kind,
            creatorId,
            userTags,
            lastSeen,
            sourceSegments,
            transcodedSegments,
            sourceSegmentsDuration,
            transcodedSegmentsDuration,
            sourceBytes,
            transcodedBytes,
            ingestRate,
            outgoingRate,
            isActive,
            isHealthy,
            issues,
            createdByTokenName,
            createdAt,
            parentId,
            streamKey,
            pull,
            playbackId,
            playbackPolicy,
            profiles,
            projectId,
            record,
            recordingSpec,
            multistream,
            suspended,
            lastTerminatedAt,
            userId,
            renditions);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Stream.class,
                "id", id,
                "name", name,
                "kind", kind,
                "creatorId", creatorId,
                "userTags", userTags,
                "lastSeen", lastSeen,
                "sourceSegments", sourceSegments,
                "transcodedSegments", transcodedSegments,
                "sourceSegmentsDuration", sourceSegmentsDuration,
                "transcodedSegmentsDuration", transcodedSegmentsDuration,
                "sourceBytes", sourceBytes,
                "transcodedBytes", transcodedBytes,
                "ingestRate", ingestRate,
                "outgoingRate", outgoingRate,
                "isActive", isActive,
                "isHealthy", isHealthy,
                "issues", issues,
                "createdByTokenName", createdByTokenName,
                "createdAt", createdAt,
                "parentId", parentId,
                "streamKey", streamKey,
                "pull", pull,
                "playbackId", playbackId,
                "playbackPolicy", playbackPolicy,
                "profiles", profiles,
                "projectId", projectId,
                "record", record,
                "recordingSpec", recordingSpec,
                "multistream", multistream,
                "suspended", suspended,
                "lastTerminatedAt", lastTerminatedAt,
                "userId", userId,
                "renditions", renditions);
    }
    
    public final static class Builder {
 
        private Optional<String> id = Optional.empty();
 
        private String name;
 
        @Deprecated
        private Optional<String> kind = Optional.empty();
 
        private Optional<? extends CreatorId> creatorId = Optional.empty();
 
        private Optional<? extends Map<String, StreamUserTags>> userTags = Optional.empty();
 
        private Optional<Double> lastSeen = Optional.empty();
 
        private Optional<Double> sourceSegments = Optional.empty();
 
        private Optional<Double> transcodedSegments = Optional.empty();
 
        private Optional<Double> sourceSegmentsDuration = Optional.empty();
 
        private Optional<Double> transcodedSegmentsDuration = Optional.empty();
 
        private Optional<Double> sourceBytes = Optional.empty();
 
        private Optional<Double> transcodedBytes = Optional.empty();
 
        private Optional<Double> ingestRate = Optional.empty();
 
        private Optional<Double> outgoingRate = Optional.empty();
 
        private Optional<Boolean> isActive = Optional.empty();
 
        private JsonNullable<Boolean> isHealthy = JsonNullable.undefined();
 
        private JsonNullable<? extends List<String>> issues = JsonNullable.undefined();
 
        private Optional<String> createdByTokenName = Optional.empty();
 
        private Optional<Double> createdAt = Optional.empty();
 
        private Optional<String> parentId = Optional.empty();
 
        private Optional<String> streamKey = Optional.empty();
 
        private Optional<? extends StreamPull> pull = Optional.empty();
 
        private Optional<String> playbackId = Optional.empty();
 
        private JsonNullable<? extends PlaybackPolicy> playbackPolicy = JsonNullable.undefined();
 
        private Optional<? extends List<FfmpegProfile>> profiles = Optional.empty();
 
        private Optional<String> projectId = Optional.empty();
 
        private Optional<Boolean> record = Optional.empty();
 
        private Optional<? extends StreamRecordingSpec> recordingSpec = Optional.empty();
 
        private Optional<? extends StreamMultistream> multistream = Optional.empty();
 
        private Optional<Boolean> suspended = Optional.empty();
 
        private JsonNullable<Double> lastTerminatedAt = JsonNullable.undefined();
 
        @Deprecated
        private Optional<String> userId = Optional.empty();
 
        private Optional<? extends Renditions> renditions = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(String kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = Optional.ofNullable(kind);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(Optional<String> kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = kind;
            return this;
        }

        public Builder creatorId(CreatorId creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = Optional.ofNullable(creatorId);
            return this;
        }

        public Builder creatorId(Optional<? extends CreatorId> creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = creatorId;
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Map<String, StreamUserTags> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = Optional.ofNullable(userTags);
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Optional<? extends Map<String, StreamUserTags>> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = userTags;
            return this;
        }

        public Builder lastSeen(double lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = Optional.ofNullable(lastSeen);
            return this;
        }

        public Builder lastSeen(Optional<Double> lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = lastSeen;
            return this;
        }

        public Builder sourceSegments(double sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = Optional.ofNullable(sourceSegments);
            return this;
        }

        public Builder sourceSegments(Optional<Double> sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = sourceSegments;
            return this;
        }

        public Builder transcodedSegments(double transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = Optional.ofNullable(transcodedSegments);
            return this;
        }

        public Builder transcodedSegments(Optional<Double> transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = transcodedSegments;
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(double sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(Optional<Double> sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = sourceSegmentsDuration;
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(double transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(Optional<Double> transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = transcodedSegmentsDuration;
            return this;
        }

        public Builder sourceBytes(double sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = Optional.ofNullable(sourceBytes);
            return this;
        }

        public Builder sourceBytes(Optional<Double> sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = sourceBytes;
            return this;
        }

        public Builder transcodedBytes(double transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = Optional.ofNullable(transcodedBytes);
            return this;
        }

        public Builder transcodedBytes(Optional<Double> transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = transcodedBytes;
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(double ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = Optional.ofNullable(ingestRate);
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(Optional<Double> ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = ingestRate;
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(double outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = Optional.ofNullable(outgoingRate);
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(Optional<Double> outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = outgoingRate;
            return this;
        }

        /**
         * If currently active
         */
        public Builder isActive(boolean isActive) {
            Utils.checkNotNull(isActive, "isActive");
            this.isActive = Optional.ofNullable(isActive);
            return this;
        }

        /**
         * If currently active
         */
        public Builder isActive(Optional<Boolean> isActive) {
            Utils.checkNotNull(isActive, "isActive");
            this.isActive = isActive;
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(boolean isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = JsonNullable.of(isHealthy);
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(JsonNullable<Boolean> isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = isHealthy;
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(List<String> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = JsonNullable.of(issues);
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(JsonNullable<? extends List<String>> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = issues;
            return this;
        }

        /**
         * Name of the token used to create this object
         */
        public Builder createdByTokenName(String createdByTokenName) {
            Utils.checkNotNull(createdByTokenName, "createdByTokenName");
            this.createdByTokenName = Optional.ofNullable(createdByTokenName);
            return this;
        }

        /**
         * Name of the token used to create this object
         */
        public Builder createdByTokenName(Optional<String> createdByTokenName) {
            Utils.checkNotNull(createdByTokenName, "createdByTokenName");
            this.createdByTokenName = createdByTokenName;
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(double createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(Optional<Double> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(String parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = Optional.ofNullable(parentId);
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(Optional<String> parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = parentId;
            return this;
        }

        /**
         * Used to form RTMP ingest URL
         */
        public Builder streamKey(String streamKey) {
            Utils.checkNotNull(streamKey, "streamKey");
            this.streamKey = Optional.ofNullable(streamKey);
            return this;
        }

        /**
         * Used to form RTMP ingest URL
         */
        public Builder streamKey(Optional<String> streamKey) {
            Utils.checkNotNull(streamKey, "streamKey");
            this.streamKey = streamKey;
            return this;
        }

        /**
         * Configuration for a stream that should be actively pulled from an
         * external source, rather than pushed to Livepeer. If specified, the
         * stream will not have a streamKey.
         */
        public Builder pull(StreamPull pull) {
            Utils.checkNotNull(pull, "pull");
            this.pull = Optional.ofNullable(pull);
            return this;
        }

        /**
         * Configuration for a stream that should be actively pulled from an
         * external source, rather than pushed to Livepeer. If specified, the
         * stream will not have a streamKey.
         */
        public Builder pull(Optional<? extends StreamPull> pull) {
            Utils.checkNotNull(pull, "pull");
            this.pull = pull;
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = Optional.ofNullable(playbackId);
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(Optional<String> playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(PlaybackPolicy playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = JsonNullable.of(playbackPolicy);
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = playbackPolicy;
            return this;
        }

        /**
         * Profiles to transcode the stream into. If not specified, a default
         * set of profiles will be used with 240p, 360p, 480p and 720p
         * resolutions. Keep in mind that the source rendition is always kept.
         * 
         */
        public Builder profiles(List<FfmpegProfile> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = Optional.ofNullable(profiles);
            return this;
        }

        /**
         * Profiles to transcode the stream into. If not specified, a default
         * set of profiles will be used with 240p, 360p, 480p and 720p
         * resolutions. Keep in mind that the source rendition is always kept.
         * 
         */
        public Builder profiles(Optional<? extends List<FfmpegProfile>> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = profiles;
            return this;
        }

        /**
         * The ID of the project
         */
        public Builder projectId(String projectId) {
            Utils.checkNotNull(projectId, "projectId");
            this.projectId = Optional.ofNullable(projectId);
            return this;
        }

        /**
         * The ID of the project
         */
        public Builder projectId(Optional<String> projectId) {
            Utils.checkNotNull(projectId, "projectId");
            this.projectId = projectId;
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(boolean record) {
            Utils.checkNotNull(record, "record");
            this.record = Optional.ofNullable(record);
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(Optional<Boolean> record) {
            Utils.checkNotNull(record, "record");
            this.record = record;
            return this;
        }

        /**
         * Configuration for recording the stream. This can only be set if
         * `record` is true.
         * 
         */
        public Builder recordingSpec(StreamRecordingSpec recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = Optional.ofNullable(recordingSpec);
            return this;
        }

        /**
         * Configuration for recording the stream. This can only be set if
         * `record` is true.
         * 
         */
        public Builder recordingSpec(Optional<? extends StreamRecordingSpec> recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = recordingSpec;
            return this;
        }

        public Builder multistream(StreamMultistream multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = Optional.ofNullable(multistream);
            return this;
        }

        public Builder multistream(Optional<? extends StreamMultistream> multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = multistream;
            return this;
        }

        /**
         * If currently suspended
         */
        public Builder suspended(boolean suspended) {
            Utils.checkNotNull(suspended, "suspended");
            this.suspended = Optional.ofNullable(suspended);
            return this;
        }

        /**
         * If currently suspended
         */
        public Builder suspended(Optional<Boolean> suspended) {
            Utils.checkNotNull(suspended, "suspended");
            this.suspended = suspended;
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the stream was last terminated
         */
        public Builder lastTerminatedAt(double lastTerminatedAt) {
            Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
            this.lastTerminatedAt = JsonNullable.of(lastTerminatedAt);
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the stream was last terminated
         */
        public Builder lastTerminatedAt(JsonNullable<Double> lastTerminatedAt) {
            Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
            this.lastTerminatedAt = lastTerminatedAt;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(String userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = Optional.ofNullable(userId);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(Optional<String> userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = userId;
            return this;
        }

        public Builder renditions(Renditions renditions) {
            Utils.checkNotNull(renditions, "renditions");
            this.renditions = Optional.ofNullable(renditions);
            return this;
        }

        public Builder renditions(Optional<? extends Renditions> renditions) {
            Utils.checkNotNull(renditions, "renditions");
            this.renditions = renditions;
            return this;
        }
        
        public Stream build() {
            return new Stream(
                id,
                name,
                kind,
                creatorId,
                userTags,
                lastSeen,
                sourceSegments,
                transcodedSegments,
                sourceSegmentsDuration,
                transcodedSegmentsDuration,
                sourceBytes,
                transcodedBytes,
                ingestRate,
                outgoingRate,
                isActive,
                isHealthy,
                issues,
                createdByTokenName,
                createdAt,
                parentId,
                streamKey,
                pull,
                playbackId,
                playbackPolicy,
                profiles,
                projectId,
                record,
                recordingSpec,
                multistream,
                suspended,
                lastTerminatedAt,
                userId,
                renditions);
        }
    }
}

