/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
import studio.livepeer.livepeer.utils.Utils;

public class Stream {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<? extends String> id;

    @JsonProperty("name")
    private String name;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kind")
    @Deprecated
    private Optional<? extends String> kind;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private Optional<? extends CreatorId> creatorId;

    /**
     * User input tags associated with the stream
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userTags")
    private Optional<? extends java.util.Map<String, StreamUserTags>> userTags;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastSeen")
    private Optional<? extends Double> lastSeen;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegments")
    private Optional<? extends Double> sourceSegments;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegments")
    private Optional<? extends Double> transcodedSegments;

    /**
     * Duration of all the source segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegmentsDuration")
    private Optional<? extends Double> sourceSegmentsDuration;

    /**
     * Duration of all the transcoded segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegmentsDuration")
    private Optional<? extends Double> transcodedSegmentsDuration;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceBytes")
    private Optional<? extends Double> sourceBytes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedBytes")
    private Optional<? extends Double> transcodedBytes;

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ingestRate")
    private Optional<? extends Double> ingestRate;

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("outgoingRate")
    private Optional<? extends Double> outgoingRate;

    /**
     * If currently active
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isActive")
    private Optional<? extends Boolean> isActive;

    /**
     * Indicates whether the stream is healthy or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isHealthy")
    private JsonNullable<? extends Boolean> isHealthy;

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issues")
    private JsonNullable<? extends java.util.List<String>> issues;

    /**
     * Name of the token used to create this object
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdByTokenName")
    private Optional<? extends String> createdByTokenName;

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<? extends Double> createdAt;

    /**
     * Points to parent stream object
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentId")
    private Optional<? extends String> parentId;

    /**
     * Used to form RTMP ingest URL
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("streamKey")
    private Optional<? extends String> streamKey;

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pull")
    private Optional<? extends StreamPull> pull;

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackId")
    private Optional<? extends String> playbackId;

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackPolicy")
    private JsonNullable<? extends PlaybackPolicy> playbackPolicy;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profiles")
    private Optional<? extends java.util.List<FfmpegProfile>> profiles;

    /**
     * The ID of the project
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("projectId")
    private Optional<? extends String> projectId;

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("record")
    private Optional<? extends Boolean> record;

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingSpec")
    private Optional<? extends StreamRecordingSpec> recordingSpec;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("multistream")
    private Optional<? extends StreamMultistream> multistream;

    /**
     * If currently suspended
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("suspended")
    private Optional<? extends Boolean> suspended;

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastTerminatedAt")
    private JsonNullable<? extends Double> lastTerminatedAt;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userId")
    @Deprecated
    private Optional<? extends String> userId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("renditions")
    private Optional<? extends Renditions> renditions;

    @JsonCreator
    public Stream(
            @JsonProperty("id") Optional<? extends String> id,
            @JsonProperty("name") String name,
            @JsonProperty("kind") Optional<? extends String> kind,
            @JsonProperty("creatorId") Optional<? extends CreatorId> creatorId,
            @JsonProperty("userTags") Optional<? extends java.util.Map<String, StreamUserTags>> userTags,
            @JsonProperty("lastSeen") Optional<? extends Double> lastSeen,
            @JsonProperty("sourceSegments") Optional<? extends Double> sourceSegments,
            @JsonProperty("transcodedSegments") Optional<? extends Double> transcodedSegments,
            @JsonProperty("sourceSegmentsDuration") Optional<? extends Double> sourceSegmentsDuration,
            @JsonProperty("transcodedSegmentsDuration") Optional<? extends Double> transcodedSegmentsDuration,
            @JsonProperty("sourceBytes") Optional<? extends Double> sourceBytes,
            @JsonProperty("transcodedBytes") Optional<? extends Double> transcodedBytes,
            @JsonProperty("ingestRate") Optional<? extends Double> ingestRate,
            @JsonProperty("outgoingRate") Optional<? extends Double> outgoingRate,
            @JsonProperty("isActive") Optional<? extends Boolean> isActive,
            @JsonProperty("isHealthy") JsonNullable<? extends Boolean> isHealthy,
            @JsonProperty("issues") JsonNullable<? extends java.util.List<String>> issues,
            @JsonProperty("createdByTokenName") Optional<? extends String> createdByTokenName,
            @JsonProperty("createdAt") Optional<? extends Double> createdAt,
            @JsonProperty("parentId") Optional<? extends String> parentId,
            @JsonProperty("streamKey") Optional<? extends String> streamKey,
            @JsonProperty("pull") Optional<? extends StreamPull> pull,
            @JsonProperty("playbackId") Optional<? extends String> playbackId,
            @JsonProperty("playbackPolicy") JsonNullable<? extends PlaybackPolicy> playbackPolicy,
            @JsonProperty("profiles") Optional<? extends java.util.List<FfmpegProfile>> profiles,
            @JsonProperty("projectId") Optional<? extends String> projectId,
            @JsonProperty("record") Optional<? extends Boolean> record,
            @JsonProperty("recordingSpec") Optional<? extends StreamRecordingSpec> recordingSpec,
            @JsonProperty("multistream") Optional<? extends StreamMultistream> multistream,
            @JsonProperty("suspended") Optional<? extends Boolean> suspended,
            @JsonProperty("lastTerminatedAt") JsonNullable<? extends Double> lastTerminatedAt,
            @JsonProperty("userId") Optional<? extends String> userId,
            @JsonProperty("renditions") Optional<? extends Renditions> renditions) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(kind, "kind");
        Utils.checkNotNull(creatorId, "creatorId");
        Utils.checkNotNull(userTags, "userTags");
        Utils.checkNotNull(lastSeen, "lastSeen");
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        Utils.checkNotNull(ingestRate, "ingestRate");
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        Utils.checkNotNull(isActive, "isActive");
        Utils.checkNotNull(isHealthy, "isHealthy");
        Utils.checkNotNull(issues, "issues");
        Utils.checkNotNull(createdByTokenName, "createdByTokenName");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(parentId, "parentId");
        Utils.checkNotNull(streamKey, "streamKey");
        Utils.checkNotNull(pull, "pull");
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        Utils.checkNotNull(profiles, "profiles");
        Utils.checkNotNull(projectId, "projectId");
        Utils.checkNotNull(record, "record");
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        Utils.checkNotNull(multistream, "multistream");
        Utils.checkNotNull(suspended, "suspended");
        Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
        Utils.checkNotNull(userId, "userId");
        Utils.checkNotNull(renditions, "renditions");
        this.id = id;
        this.name = name;
        this.kind = kind;
        this.creatorId = creatorId;
        this.userTags = userTags;
        this.lastSeen = lastSeen;
        this.sourceSegments = sourceSegments;
        this.transcodedSegments = transcodedSegments;
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        this.sourceBytes = sourceBytes;
        this.transcodedBytes = transcodedBytes;
        this.ingestRate = ingestRate;
        this.outgoingRate = outgoingRate;
        this.isActive = isActive;
        this.isHealthy = isHealthy;
        this.issues = issues;
        this.createdByTokenName = createdByTokenName;
        this.createdAt = createdAt;
        this.parentId = parentId;
        this.streamKey = streamKey;
        this.pull = pull;
        this.playbackId = playbackId;
        this.playbackPolicy = playbackPolicy;
        this.profiles = profiles;
        this.projectId = projectId;
        this.record = record;
        this.recordingSpec = recordingSpec;
        this.multistream = multistream;
        this.suspended = suspended;
        this.lastTerminatedAt = lastTerminatedAt;
        this.userId = userId;
        this.renditions = renditions;
    }
    
    public Stream(
            String name) {
        this(Optional.empty(), name, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> id() {
        return (Optional<String>) id;
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> kind() {
        return (Optional<String>) kind;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreatorId> creatorId() {
        return (Optional<CreatorId>) creatorId;
    }

    /**
     * User input tags associated with the stream
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<java.util.Map<String, StreamUserTags>> userTags() {
        return (Optional<java.util.Map<String, StreamUserTags>>) userTags;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> lastSeen() {
        return (Optional<Double>) lastSeen;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sourceSegments() {
        return (Optional<Double>) sourceSegments;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> transcodedSegments() {
        return (Optional<Double>) transcodedSegments;
    }

    /**
     * Duration of all the source segments, sec
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sourceSegmentsDuration() {
        return (Optional<Double>) sourceSegmentsDuration;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> transcodedSegmentsDuration() {
        return (Optional<Double>) transcodedSegmentsDuration;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sourceBytes() {
        return (Optional<Double>) sourceBytes;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> transcodedBytes() {
        return (Optional<Double>) transcodedBytes;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> ingestRate() {
        return (Optional<Double>) ingestRate;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> outgoingRate() {
        return (Optional<Double>) outgoingRate;
    }

    /**
     * If currently active
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Boolean> isActive() {
        return (Optional<Boolean>) isActive;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Boolean> isHealthy() {
        return (JsonNullable<Boolean>) isHealthy;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<java.util.List<String>> issues() {
        return (JsonNullable<java.util.List<String>>) issues;
    }

    /**
     * Name of the token used to create this object
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> createdByTokenName() {
        return (Optional<String>) createdByTokenName;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> createdAt() {
        return (Optional<Double>) createdAt;
    }

    /**
     * Points to parent stream object
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> parentId() {
        return (Optional<String>) parentId;
    }

    /**
     * Used to form RTMP ingest URL
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> streamKey() {
        return (Optional<String>) streamKey;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StreamPull> pull() {
        return (Optional<StreamPull>) pull;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> playbackId() {
        return (Optional<String>) playbackId;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PlaybackPolicy> playbackPolicy() {
        return (JsonNullable<PlaybackPolicy>) playbackPolicy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<java.util.List<FfmpegProfile>> profiles() {
        return (Optional<java.util.List<FfmpegProfile>>) profiles;
    }

    /**
     * The ID of the project
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> projectId() {
        return (Optional<String>) projectId;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Boolean> record() {
        return (Optional<Boolean>) record;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StreamRecordingSpec> recordingSpec() {
        return (Optional<StreamRecordingSpec>) recordingSpec;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<StreamMultistream> multistream() {
        return (Optional<StreamMultistream>) multistream;
    }

    /**
     * If currently suspended
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Boolean> suspended() {
        return (Optional<Boolean>) suspended;
    }

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Double> lastTerminatedAt() {
        return (JsonNullable<Double>) lastTerminatedAt;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> userId() {
        return (Optional<String>) userId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Renditions> renditions() {
        return (Optional<Renditions>) renditions;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public Stream withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    public Stream withId(Optional<? extends String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public Stream withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withKind(String kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = Optional.ofNullable(kind);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withKind(Optional<? extends String> kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = kind;
        return this;
    }

    public Stream withCreatorId(CreatorId creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = Optional.ofNullable(creatorId);
        return this;
    }

    public Stream withCreatorId(Optional<? extends CreatorId> creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = creatorId;
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public Stream withUserTags(java.util.Map<String, StreamUserTags> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = Optional.ofNullable(userTags);
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public Stream withUserTags(Optional<? extends java.util.Map<String, StreamUserTags>> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = userTags;
        return this;
    }

    public Stream withLastSeen(double lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = Optional.ofNullable(lastSeen);
        return this;
    }

    public Stream withLastSeen(Optional<? extends Double> lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = lastSeen;
        return this;
    }

    public Stream withSourceSegments(double sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = Optional.ofNullable(sourceSegments);
        return this;
    }

    public Stream withSourceSegments(Optional<? extends Double> sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = sourceSegments;
        return this;
    }

    public Stream withTranscodedSegments(double transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = Optional.ofNullable(transcodedSegments);
        return this;
    }

    public Stream withTranscodedSegments(Optional<? extends Double> transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = transcodedSegments;
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Stream withSourceSegmentsDuration(double sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Stream withSourceSegmentsDuration(Optional<? extends Double> sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Stream withTranscodedSegmentsDuration(double transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Stream withTranscodedSegmentsDuration(Optional<? extends Double> transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        return this;
    }

    public Stream withSourceBytes(double sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = Optional.ofNullable(sourceBytes);
        return this;
    }

    public Stream withSourceBytes(Optional<? extends Double> sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = sourceBytes;
        return this;
    }

    public Stream withTranscodedBytes(double transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = Optional.ofNullable(transcodedBytes);
        return this;
    }

    public Stream withTranscodedBytes(Optional<? extends Double> transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = transcodedBytes;
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Stream withIngestRate(double ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = Optional.ofNullable(ingestRate);
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Stream withIngestRate(Optional<? extends Double> ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = ingestRate;
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Stream withOutgoingRate(double outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = Optional.ofNullable(outgoingRate);
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Stream withOutgoingRate(Optional<? extends Double> outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = outgoingRate;
        return this;
    }

    /**
     * If currently active
     */
    public Stream withIsActive(boolean isActive) {
        Utils.checkNotNull(isActive, "isActive");
        this.isActive = Optional.ofNullable(isActive);
        return this;
    }

    /**
     * If currently active
     */
    public Stream withIsActive(Optional<? extends Boolean> isActive) {
        Utils.checkNotNull(isActive, "isActive");
        this.isActive = isActive;
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Stream withIsHealthy(boolean isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = JsonNullable.of(isHealthy);
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Stream withIsHealthy(JsonNullable<? extends Boolean> isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = isHealthy;
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Stream withIssues(java.util.List<String> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = JsonNullable.of(issues);
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Stream withIssues(JsonNullable<? extends java.util.List<String>> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = issues;
        return this;
    }

    /**
     * Name of the token used to create this object
     */
    public Stream withCreatedByTokenName(String createdByTokenName) {
        Utils.checkNotNull(createdByTokenName, "createdByTokenName");
        this.createdByTokenName = Optional.ofNullable(createdByTokenName);
        return this;
    }

    /**
     * Name of the token used to create this object
     */
    public Stream withCreatedByTokenName(Optional<? extends String> createdByTokenName) {
        Utils.checkNotNull(createdByTokenName, "createdByTokenName");
        this.createdByTokenName = createdByTokenName;
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Stream withCreatedAt(double createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Stream withCreatedAt(Optional<? extends Double> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Stream withParentId(String parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = Optional.ofNullable(parentId);
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Stream withParentId(Optional<? extends String> parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = parentId;
        return this;
    }

    /**
     * Used to form RTMP ingest URL
     */
    public Stream withStreamKey(String streamKey) {
        Utils.checkNotNull(streamKey, "streamKey");
        this.streamKey = Optional.ofNullable(streamKey);
        return this;
    }

    /**
     * Used to form RTMP ingest URL
     */
    public Stream withStreamKey(Optional<? extends String> streamKey) {
        Utils.checkNotNull(streamKey, "streamKey");
        this.streamKey = streamKey;
        return this;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    public Stream withPull(StreamPull pull) {
        Utils.checkNotNull(pull, "pull");
        this.pull = Optional.ofNullable(pull);
        return this;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    public Stream withPull(Optional<? extends StreamPull> pull) {
        Utils.checkNotNull(pull, "pull");
        this.pull = pull;
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Stream withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = Optional.ofNullable(playbackId);
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Stream withPlaybackId(Optional<? extends String> playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public Stream withPlaybackPolicy(PlaybackPolicy playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = JsonNullable.of(playbackPolicy);
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public Stream withPlaybackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = playbackPolicy;
        return this;
    }

    public Stream withProfiles(java.util.List<FfmpegProfile> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = Optional.ofNullable(profiles);
        return this;
    }

    public Stream withProfiles(Optional<? extends java.util.List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = profiles;
        return this;
    }

    /**
     * The ID of the project
     */
    public Stream withProjectId(String projectId) {
        Utils.checkNotNull(projectId, "projectId");
        this.projectId = Optional.ofNullable(projectId);
        return this;
    }

    /**
     * The ID of the project
     */
    public Stream withProjectId(Optional<? extends String> projectId) {
        Utils.checkNotNull(projectId, "projectId");
        this.projectId = projectId;
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public Stream withRecord(boolean record) {
        Utils.checkNotNull(record, "record");
        this.record = Optional.ofNullable(record);
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public Stream withRecord(Optional<? extends Boolean> record) {
        Utils.checkNotNull(record, "record");
        this.record = record;
        return this;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    public Stream withRecordingSpec(StreamRecordingSpec recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = Optional.ofNullable(recordingSpec);
        return this;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    public Stream withRecordingSpec(Optional<? extends StreamRecordingSpec> recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = recordingSpec;
        return this;
    }

    public Stream withMultistream(StreamMultistream multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = Optional.ofNullable(multistream);
        return this;
    }

    public Stream withMultistream(Optional<? extends StreamMultistream> multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = multistream;
        return this;
    }

    /**
     * If currently suspended
     */
    public Stream withSuspended(boolean suspended) {
        Utils.checkNotNull(suspended, "suspended");
        this.suspended = Optional.ofNullable(suspended);
        return this;
    }

    /**
     * If currently suspended
     */
    public Stream withSuspended(Optional<? extends Boolean> suspended) {
        Utils.checkNotNull(suspended, "suspended");
        this.suspended = suspended;
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    public Stream withLastTerminatedAt(double lastTerminatedAt) {
        Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
        this.lastTerminatedAt = JsonNullable.of(lastTerminatedAt);
        return this;
    }

    /**
     * Timestamp (in milliseconds) when the stream was last terminated
     */
    public Stream withLastTerminatedAt(JsonNullable<? extends Double> lastTerminatedAt) {
        Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
        this.lastTerminatedAt = lastTerminatedAt;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withUserId(String userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = Optional.ofNullable(userId);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Stream withUserId(Optional<? extends String> userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = userId;
        return this;
    }

    public Stream withRenditions(Renditions renditions) {
        Utils.checkNotNull(renditions, "renditions");
        this.renditions = Optional.ofNullable(renditions);
        return this;
    }

    public Stream withRenditions(Optional<? extends Renditions> renditions) {
        Utils.checkNotNull(renditions, "renditions");
        this.renditions = renditions;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Stream other = (Stream) o;
        return 
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.name, other.name) &&
            java.util.Objects.deepEquals(this.kind, other.kind) &&
            java.util.Objects.deepEquals(this.creatorId, other.creatorId) &&
            java.util.Objects.deepEquals(this.userTags, other.userTags) &&
            java.util.Objects.deepEquals(this.lastSeen, other.lastSeen) &&
            java.util.Objects.deepEquals(this.sourceSegments, other.sourceSegments) &&
            java.util.Objects.deepEquals(this.transcodedSegments, other.transcodedSegments) &&
            java.util.Objects.deepEquals(this.sourceSegmentsDuration, other.sourceSegmentsDuration) &&
            java.util.Objects.deepEquals(this.transcodedSegmentsDuration, other.transcodedSegmentsDuration) &&
            java.util.Objects.deepEquals(this.sourceBytes, other.sourceBytes) &&
            java.util.Objects.deepEquals(this.transcodedBytes, other.transcodedBytes) &&
            java.util.Objects.deepEquals(this.ingestRate, other.ingestRate) &&
            java.util.Objects.deepEquals(this.outgoingRate, other.outgoingRate) &&
            java.util.Objects.deepEquals(this.isActive, other.isActive) &&
            java.util.Objects.deepEquals(this.isHealthy, other.isHealthy) &&
            java.util.Objects.deepEquals(this.issues, other.issues) &&
            java.util.Objects.deepEquals(this.createdByTokenName, other.createdByTokenName) &&
            java.util.Objects.deepEquals(this.createdAt, other.createdAt) &&
            java.util.Objects.deepEquals(this.parentId, other.parentId) &&
            java.util.Objects.deepEquals(this.streamKey, other.streamKey) &&
            java.util.Objects.deepEquals(this.pull, other.pull) &&
            java.util.Objects.deepEquals(this.playbackId, other.playbackId) &&
            java.util.Objects.deepEquals(this.playbackPolicy, other.playbackPolicy) &&
            java.util.Objects.deepEquals(this.profiles, other.profiles) &&
            java.util.Objects.deepEquals(this.projectId, other.projectId) &&
            java.util.Objects.deepEquals(this.record, other.record) &&
            java.util.Objects.deepEquals(this.recordingSpec, other.recordingSpec) &&
            java.util.Objects.deepEquals(this.multistream, other.multistream) &&
            java.util.Objects.deepEquals(this.suspended, other.suspended) &&
            java.util.Objects.deepEquals(this.lastTerminatedAt, other.lastTerminatedAt) &&
            java.util.Objects.deepEquals(this.userId, other.userId) &&
            java.util.Objects.deepEquals(this.renditions, other.renditions);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            id,
            name,
            kind,
            creatorId,
            userTags,
            lastSeen,
            sourceSegments,
            transcodedSegments,
            sourceSegmentsDuration,
            transcodedSegmentsDuration,
            sourceBytes,
            transcodedBytes,
            ingestRate,
            outgoingRate,
            isActive,
            isHealthy,
            issues,
            createdByTokenName,
            createdAt,
            parentId,
            streamKey,
            pull,
            playbackId,
            playbackPolicy,
            profiles,
            projectId,
            record,
            recordingSpec,
            multistream,
            suspended,
            lastTerminatedAt,
            userId,
            renditions);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Stream.class,
                "id", id,
                "name", name,
                "kind", kind,
                "creatorId", creatorId,
                "userTags", userTags,
                "lastSeen", lastSeen,
                "sourceSegments", sourceSegments,
                "transcodedSegments", transcodedSegments,
                "sourceSegmentsDuration", sourceSegmentsDuration,
                "transcodedSegmentsDuration", transcodedSegmentsDuration,
                "sourceBytes", sourceBytes,
                "transcodedBytes", transcodedBytes,
                "ingestRate", ingestRate,
                "outgoingRate", outgoingRate,
                "isActive", isActive,
                "isHealthy", isHealthy,
                "issues", issues,
                "createdByTokenName", createdByTokenName,
                "createdAt", createdAt,
                "parentId", parentId,
                "streamKey", streamKey,
                "pull", pull,
                "playbackId", playbackId,
                "playbackPolicy", playbackPolicy,
                "profiles", profiles,
                "projectId", projectId,
                "record", record,
                "recordingSpec", recordingSpec,
                "multistream", multistream,
                "suspended", suspended,
                "lastTerminatedAt", lastTerminatedAt,
                "userId", userId,
                "renditions", renditions);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> id = Optional.empty();
 
        private String name;
 
        @Deprecated
        private Optional<? extends String> kind = Optional.empty();
 
        private Optional<? extends CreatorId> creatorId = Optional.empty();
 
        private Optional<? extends java.util.Map<String, StreamUserTags>> userTags = Optional.empty();
 
        private Optional<? extends Double> lastSeen = Optional.empty();
 
        private Optional<? extends Double> sourceSegments = Optional.empty();
 
        private Optional<? extends Double> transcodedSegments = Optional.empty();
 
        private Optional<? extends Double> sourceSegmentsDuration = Optional.empty();
 
        private Optional<? extends Double> transcodedSegmentsDuration = Optional.empty();
 
        private Optional<? extends Double> sourceBytes = Optional.empty();
 
        private Optional<? extends Double> transcodedBytes = Optional.empty();
 
        private Optional<? extends Double> ingestRate = Optional.empty();
 
        private Optional<? extends Double> outgoingRate = Optional.empty();
 
        private Optional<? extends Boolean> isActive = Optional.empty();
 
        private JsonNullable<? extends Boolean> isHealthy = JsonNullable.undefined();
 
        private JsonNullable<? extends java.util.List<String>> issues = JsonNullable.undefined();
 
        private Optional<? extends String> createdByTokenName = Optional.empty();
 
        private Optional<? extends Double> createdAt = Optional.empty();
 
        private Optional<? extends String> parentId = Optional.empty();
 
        private Optional<? extends String> streamKey = Optional.empty();
 
        private Optional<? extends StreamPull> pull = Optional.empty();
 
        private Optional<? extends String> playbackId = Optional.empty();
 
        private JsonNullable<? extends PlaybackPolicy> playbackPolicy = JsonNullable.undefined();
 
        private Optional<? extends java.util.List<FfmpegProfile>> profiles = Optional.empty();
 
        private Optional<? extends String> projectId = Optional.empty();
 
        private Optional<? extends Boolean> record = Optional.empty();
 
        private Optional<? extends StreamRecordingSpec> recordingSpec = Optional.empty();
 
        private Optional<? extends StreamMultistream> multistream = Optional.empty();
 
        private Optional<? extends Boolean> suspended = Optional.empty();
 
        private JsonNullable<? extends Double> lastTerminatedAt = JsonNullable.undefined();
 
        @Deprecated
        private Optional<? extends String> userId = Optional.empty();
 
        private Optional<? extends Renditions> renditions = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<? extends String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(String kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = Optional.ofNullable(kind);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(Optional<? extends String> kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = kind;
            return this;
        }

        public Builder creatorId(CreatorId creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = Optional.ofNullable(creatorId);
            return this;
        }

        public Builder creatorId(Optional<? extends CreatorId> creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = creatorId;
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(java.util.Map<String, StreamUserTags> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = Optional.ofNullable(userTags);
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Optional<? extends java.util.Map<String, StreamUserTags>> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = userTags;
            return this;
        }

        public Builder lastSeen(double lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = Optional.ofNullable(lastSeen);
            return this;
        }

        public Builder lastSeen(Optional<? extends Double> lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = lastSeen;
            return this;
        }

        public Builder sourceSegments(double sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = Optional.ofNullable(sourceSegments);
            return this;
        }

        public Builder sourceSegments(Optional<? extends Double> sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = sourceSegments;
            return this;
        }

        public Builder transcodedSegments(double transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = Optional.ofNullable(transcodedSegments);
            return this;
        }

        public Builder transcodedSegments(Optional<? extends Double> transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = transcodedSegments;
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(double sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(Optional<? extends Double> sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = sourceSegmentsDuration;
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(double transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(Optional<? extends Double> transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = transcodedSegmentsDuration;
            return this;
        }

        public Builder sourceBytes(double sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = Optional.ofNullable(sourceBytes);
            return this;
        }

        public Builder sourceBytes(Optional<? extends Double> sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = sourceBytes;
            return this;
        }

        public Builder transcodedBytes(double transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = Optional.ofNullable(transcodedBytes);
            return this;
        }

        public Builder transcodedBytes(Optional<? extends Double> transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = transcodedBytes;
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(double ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = Optional.ofNullable(ingestRate);
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(Optional<? extends Double> ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = ingestRate;
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(double outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = Optional.ofNullable(outgoingRate);
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(Optional<? extends Double> outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = outgoingRate;
            return this;
        }

        /**
         * If currently active
         */
        public Builder isActive(boolean isActive) {
            Utils.checkNotNull(isActive, "isActive");
            this.isActive = Optional.ofNullable(isActive);
            return this;
        }

        /**
         * If currently active
         */
        public Builder isActive(Optional<? extends Boolean> isActive) {
            Utils.checkNotNull(isActive, "isActive");
            this.isActive = isActive;
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(boolean isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = JsonNullable.of(isHealthy);
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(JsonNullable<? extends Boolean> isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = isHealthy;
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(java.util.List<String> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = JsonNullable.of(issues);
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(JsonNullable<? extends java.util.List<String>> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = issues;
            return this;
        }

        /**
         * Name of the token used to create this object
         */
        public Builder createdByTokenName(String createdByTokenName) {
            Utils.checkNotNull(createdByTokenName, "createdByTokenName");
            this.createdByTokenName = Optional.ofNullable(createdByTokenName);
            return this;
        }

        /**
         * Name of the token used to create this object
         */
        public Builder createdByTokenName(Optional<? extends String> createdByTokenName) {
            Utils.checkNotNull(createdByTokenName, "createdByTokenName");
            this.createdByTokenName = createdByTokenName;
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(double createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(Optional<? extends Double> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(String parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = Optional.ofNullable(parentId);
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(Optional<? extends String> parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = parentId;
            return this;
        }

        /**
         * Used to form RTMP ingest URL
         */
        public Builder streamKey(String streamKey) {
            Utils.checkNotNull(streamKey, "streamKey");
            this.streamKey = Optional.ofNullable(streamKey);
            return this;
        }

        /**
         * Used to form RTMP ingest URL
         */
        public Builder streamKey(Optional<? extends String> streamKey) {
            Utils.checkNotNull(streamKey, "streamKey");
            this.streamKey = streamKey;
            return this;
        }

        /**
         * Configuration for a stream that should be actively pulled from an
         * external source, rather than pushed to Livepeer. If specified, the
         * stream will not have a streamKey.
         */
        public Builder pull(StreamPull pull) {
            Utils.checkNotNull(pull, "pull");
            this.pull = Optional.ofNullable(pull);
            return this;
        }

        /**
         * Configuration for a stream that should be actively pulled from an
         * external source, rather than pushed to Livepeer. If specified, the
         * stream will not have a streamKey.
         */
        public Builder pull(Optional<? extends StreamPull> pull) {
            Utils.checkNotNull(pull, "pull");
            this.pull = pull;
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = Optional.ofNullable(playbackId);
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(Optional<? extends String> playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(PlaybackPolicy playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = JsonNullable.of(playbackPolicy);
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = playbackPolicy;
            return this;
        }

        public Builder profiles(java.util.List<FfmpegProfile> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = Optional.ofNullable(profiles);
            return this;
        }

        public Builder profiles(Optional<? extends java.util.List<FfmpegProfile>> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = profiles;
            return this;
        }

        /**
         * The ID of the project
         */
        public Builder projectId(String projectId) {
            Utils.checkNotNull(projectId, "projectId");
            this.projectId = Optional.ofNullable(projectId);
            return this;
        }

        /**
         * The ID of the project
         */
        public Builder projectId(Optional<? extends String> projectId) {
            Utils.checkNotNull(projectId, "projectId");
            this.projectId = projectId;
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(boolean record) {
            Utils.checkNotNull(record, "record");
            this.record = Optional.ofNullable(record);
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(Optional<? extends Boolean> record) {
            Utils.checkNotNull(record, "record");
            this.record = record;
            return this;
        }

        /**
         * Configuration for recording the stream. This can only be set if
         * `record` is true.
         * 
         */
        public Builder recordingSpec(StreamRecordingSpec recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = Optional.ofNullable(recordingSpec);
            return this;
        }

        /**
         * Configuration for recording the stream. This can only be set if
         * `record` is true.
         * 
         */
        public Builder recordingSpec(Optional<? extends StreamRecordingSpec> recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = recordingSpec;
            return this;
        }

        public Builder multistream(StreamMultistream multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = Optional.ofNullable(multistream);
            return this;
        }

        public Builder multistream(Optional<? extends StreamMultistream> multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = multistream;
            return this;
        }

        /**
         * If currently suspended
         */
        public Builder suspended(boolean suspended) {
            Utils.checkNotNull(suspended, "suspended");
            this.suspended = Optional.ofNullable(suspended);
            return this;
        }

        /**
         * If currently suspended
         */
        public Builder suspended(Optional<? extends Boolean> suspended) {
            Utils.checkNotNull(suspended, "suspended");
            this.suspended = suspended;
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the stream was last terminated
         */
        public Builder lastTerminatedAt(double lastTerminatedAt) {
            Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
            this.lastTerminatedAt = JsonNullable.of(lastTerminatedAt);
            return this;
        }

        /**
         * Timestamp (in milliseconds) when the stream was last terminated
         */
        public Builder lastTerminatedAt(JsonNullable<? extends Double> lastTerminatedAt) {
            Utils.checkNotNull(lastTerminatedAt, "lastTerminatedAt");
            this.lastTerminatedAt = lastTerminatedAt;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(String userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = Optional.ofNullable(userId);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(Optional<? extends String> userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = userId;
            return this;
        }

        public Builder renditions(Renditions renditions) {
            Utils.checkNotNull(renditions, "renditions");
            this.renditions = Optional.ofNullable(renditions);
            return this;
        }

        public Builder renditions(Optional<? extends Renditions> renditions) {
            Utils.checkNotNull(renditions, "renditions");
            this.renditions = renditions;
            return this;
        }
        
        public Stream build() {
            return new Stream(
                id,
                name,
                kind,
                creatorId,
                userTags,
                lastSeen,
                sourceSegments,
                transcodedSegments,
                sourceSegmentsDuration,
                transcodedSegmentsDuration,
                sourceBytes,
                transcodedBytes,
                ingestRate,
                outgoingRate,
                isActive,
                isHealthy,
                issues,
                createdByTokenName,
                createdAt,
                parentId,
                streamKey,
                pull,
                playbackId,
                playbackPolicy,
                profiles,
                projectId,
                record,
                recordingSpec,
                multistream,
                suspended,
                lastTerminatedAt,
                userId,
                renditions);
        }
    }
}

