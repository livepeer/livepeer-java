/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
import studio.livepeer.livepeer.utils.Utils;

public class Session {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<? extends String> id;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kind")
    @Deprecated
    private Optional<? extends String> kind;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userId")
    @Deprecated
    private Optional<? extends String> userId;

    @JsonProperty("name")
    private String name;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastSeen")
    private Optional<? extends Double> lastSeen;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegments")
    private Optional<? extends Double> sourceSegments;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegments")
    private Optional<? extends Double> transcodedSegments;

    /**
     * Duration of all the source segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegmentsDuration")
    private Optional<? extends Double> sourceSegmentsDuration;

    /**
     * Duration of all the transcoded segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegmentsDuration")
    private Optional<? extends Double> transcodedSegmentsDuration;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceBytes")
    private Optional<? extends Double> sourceBytes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedBytes")
    private Optional<? extends Double> transcodedBytes;

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ingestRate")
    private Optional<? extends Double> ingestRate;

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("outgoingRate")
    private Optional<? extends Double> outgoingRate;

    /**
     * Indicates whether the stream is healthy or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isHealthy")
    private JsonNullable<? extends Boolean> isHealthy;

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issues")
    private JsonNullable<? extends java.util.List<String>> issues;

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<? extends Double> createdAt;

    /**
     * Points to parent stream object
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentId")
    private Optional<? extends String> parentId;

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("record")
    private Optional<? extends Boolean> record;

    /**
     * The status of the recording process of this stream session.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingStatus")
    private Optional<? extends RecordingStatus> recordingStatus;

    /**
     * URL for accessing the recording of this stream session.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingUrl")
    private Optional<? extends String> recordingUrl;

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mp4Url")
    private Optional<? extends String> mp4Url;

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackId")
    private Optional<? extends String> playbackId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profiles")
    private Optional<? extends java.util.List<FfmpegProfile>> profiles;

    @JsonCreator
    public Session(
            @JsonProperty("id") Optional<? extends String> id,
            @JsonProperty("kind") Optional<? extends String> kind,
            @JsonProperty("userId") Optional<? extends String> userId,
            @JsonProperty("name") String name,
            @JsonProperty("lastSeen") Optional<? extends Double> lastSeen,
            @JsonProperty("sourceSegments") Optional<? extends Double> sourceSegments,
            @JsonProperty("transcodedSegments") Optional<? extends Double> transcodedSegments,
            @JsonProperty("sourceSegmentsDuration") Optional<? extends Double> sourceSegmentsDuration,
            @JsonProperty("transcodedSegmentsDuration") Optional<? extends Double> transcodedSegmentsDuration,
            @JsonProperty("sourceBytes") Optional<? extends Double> sourceBytes,
            @JsonProperty("transcodedBytes") Optional<? extends Double> transcodedBytes,
            @JsonProperty("ingestRate") Optional<? extends Double> ingestRate,
            @JsonProperty("outgoingRate") Optional<? extends Double> outgoingRate,
            @JsonProperty("isHealthy") JsonNullable<? extends Boolean> isHealthy,
            @JsonProperty("issues") JsonNullable<? extends java.util.List<String>> issues,
            @JsonProperty("createdAt") Optional<? extends Double> createdAt,
            @JsonProperty("parentId") Optional<? extends String> parentId,
            @JsonProperty("record") Optional<? extends Boolean> record,
            @JsonProperty("recordingStatus") Optional<? extends RecordingStatus> recordingStatus,
            @JsonProperty("recordingUrl") Optional<? extends String> recordingUrl,
            @JsonProperty("mp4Url") Optional<? extends String> mp4Url,
            @JsonProperty("playbackId") Optional<? extends String> playbackId,
            @JsonProperty("profiles") Optional<? extends java.util.List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(kind, "kind");
        Utils.checkNotNull(userId, "userId");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(lastSeen, "lastSeen");
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        Utils.checkNotNull(ingestRate, "ingestRate");
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        Utils.checkNotNull(isHealthy, "isHealthy");
        Utils.checkNotNull(issues, "issues");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(parentId, "parentId");
        Utils.checkNotNull(record, "record");
        Utils.checkNotNull(recordingStatus, "recordingStatus");
        Utils.checkNotNull(recordingUrl, "recordingUrl");
        Utils.checkNotNull(mp4Url, "mp4Url");
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(profiles, "profiles");
        this.id = id;
        this.kind = kind;
        this.userId = userId;
        this.name = name;
        this.lastSeen = lastSeen;
        this.sourceSegments = sourceSegments;
        this.transcodedSegments = transcodedSegments;
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        this.sourceBytes = sourceBytes;
        this.transcodedBytes = transcodedBytes;
        this.ingestRate = ingestRate;
        this.outgoingRate = outgoingRate;
        this.isHealthy = isHealthy;
        this.issues = issues;
        this.createdAt = createdAt;
        this.parentId = parentId;
        this.record = record;
        this.recordingStatus = recordingStatus;
        this.recordingUrl = recordingUrl;
        this.mp4Url = mp4Url;
        this.playbackId = playbackId;
        this.profiles = profiles;
    }
    
    public Session(
            String name) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), name, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> id() {
        return (Optional<String>) id;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> kind() {
        return (Optional<String>) kind;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> userId() {
        return (Optional<String>) userId;
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> lastSeen() {
        return (Optional<Double>) lastSeen;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sourceSegments() {
        return (Optional<Double>) sourceSegments;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> transcodedSegments() {
        return (Optional<Double>) transcodedSegments;
    }

    /**
     * Duration of all the source segments, sec
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sourceSegmentsDuration() {
        return (Optional<Double>) sourceSegmentsDuration;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> transcodedSegmentsDuration() {
        return (Optional<Double>) transcodedSegmentsDuration;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sourceBytes() {
        return (Optional<Double>) sourceBytes;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> transcodedBytes() {
        return (Optional<Double>) transcodedBytes;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> ingestRate() {
        return (Optional<Double>) ingestRate;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> outgoingRate() {
        return (Optional<Double>) outgoingRate;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Boolean> isHealthy() {
        return (JsonNullable<Boolean>) isHealthy;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<java.util.List<String>> issues() {
        return (JsonNullable<java.util.List<String>>) issues;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> createdAt() {
        return (Optional<Double>) createdAt;
    }

    /**
     * Points to parent stream object
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> parentId() {
        return (Optional<String>) parentId;
    }

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Boolean> record() {
        return (Optional<Boolean>) record;
    }

    /**
     * The status of the recording process of this stream session.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<RecordingStatus> recordingStatus() {
        return (Optional<RecordingStatus>) recordingStatus;
    }

    /**
     * URL for accessing the recording of this stream session.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> recordingUrl() {
        return (Optional<String>) recordingUrl;
    }

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> mp4Url() {
        return (Optional<String>) mp4Url;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> playbackId() {
        return (Optional<String>) playbackId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<java.util.List<FfmpegProfile>> profiles() {
        return (Optional<java.util.List<FfmpegProfile>>) profiles;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public Session withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    public Session withId(Optional<? extends String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withKind(String kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = Optional.ofNullable(kind);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withKind(Optional<? extends String> kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = kind;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withUserId(String userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = Optional.ofNullable(userId);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withUserId(Optional<? extends String> userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = userId;
        return this;
    }

    public Session withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    public Session withLastSeen(double lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = Optional.ofNullable(lastSeen);
        return this;
    }

    public Session withLastSeen(Optional<? extends Double> lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = lastSeen;
        return this;
    }

    public Session withSourceSegments(double sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = Optional.ofNullable(sourceSegments);
        return this;
    }

    public Session withSourceSegments(Optional<? extends Double> sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = sourceSegments;
        return this;
    }

    public Session withTranscodedSegments(double transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = Optional.ofNullable(transcodedSegments);
        return this;
    }

    public Session withTranscodedSegments(Optional<? extends Double> transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = transcodedSegments;
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Session withSourceSegmentsDuration(double sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Session withSourceSegmentsDuration(Optional<? extends Double> sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Session withTranscodedSegmentsDuration(double transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Session withTranscodedSegmentsDuration(Optional<? extends Double> transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        return this;
    }

    public Session withSourceBytes(double sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = Optional.ofNullable(sourceBytes);
        return this;
    }

    public Session withSourceBytes(Optional<? extends Double> sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = sourceBytes;
        return this;
    }

    public Session withTranscodedBytes(double transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = Optional.ofNullable(transcodedBytes);
        return this;
    }

    public Session withTranscodedBytes(Optional<? extends Double> transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = transcodedBytes;
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Session withIngestRate(double ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = Optional.ofNullable(ingestRate);
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Session withIngestRate(Optional<? extends Double> ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = ingestRate;
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Session withOutgoingRate(double outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = Optional.ofNullable(outgoingRate);
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Session withOutgoingRate(Optional<? extends Double> outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = outgoingRate;
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Session withIsHealthy(boolean isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = JsonNullable.of(isHealthy);
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Session withIsHealthy(JsonNullable<? extends Boolean> isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = isHealthy;
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Session withIssues(java.util.List<String> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = JsonNullable.of(issues);
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Session withIssues(JsonNullable<? extends java.util.List<String>> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = issues;
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Session withCreatedAt(double createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Session withCreatedAt(Optional<? extends Double> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Session withParentId(String parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = Optional.ofNullable(parentId);
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Session withParentId(Optional<? extends String> parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = parentId;
        return this;
    }

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    public Session withRecord(boolean record) {
        Utils.checkNotNull(record, "record");
        this.record = Optional.ofNullable(record);
        return this;
    }

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    public Session withRecord(Optional<? extends Boolean> record) {
        Utils.checkNotNull(record, "record");
        this.record = record;
        return this;
    }

    /**
     * The status of the recording process of this stream session.
     */
    public Session withRecordingStatus(RecordingStatus recordingStatus) {
        Utils.checkNotNull(recordingStatus, "recordingStatus");
        this.recordingStatus = Optional.ofNullable(recordingStatus);
        return this;
    }

    /**
     * The status of the recording process of this stream session.
     */
    public Session withRecordingStatus(Optional<? extends RecordingStatus> recordingStatus) {
        Utils.checkNotNull(recordingStatus, "recordingStatus");
        this.recordingStatus = recordingStatus;
        return this;
    }

    /**
     * URL for accessing the recording of this stream session.
     */
    public Session withRecordingUrl(String recordingUrl) {
        Utils.checkNotNull(recordingUrl, "recordingUrl");
        this.recordingUrl = Optional.ofNullable(recordingUrl);
        return this;
    }

    /**
     * URL for accessing the recording of this stream session.
     */
    public Session withRecordingUrl(Optional<? extends String> recordingUrl) {
        Utils.checkNotNull(recordingUrl, "recordingUrl");
        this.recordingUrl = recordingUrl;
        return this;
    }

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    public Session withMp4Url(String mp4Url) {
        Utils.checkNotNull(mp4Url, "mp4Url");
        this.mp4Url = Optional.ofNullable(mp4Url);
        return this;
    }

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    public Session withMp4Url(Optional<? extends String> mp4Url) {
        Utils.checkNotNull(mp4Url, "mp4Url");
        this.mp4Url = mp4Url;
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Session withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = Optional.ofNullable(playbackId);
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Session withPlaybackId(Optional<? extends String> playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    public Session withProfiles(java.util.List<FfmpegProfile> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = Optional.ofNullable(profiles);
        return this;
    }

    public Session withProfiles(Optional<? extends java.util.List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = profiles;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Session other = (Session) o;
        return 
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.kind, other.kind) &&
            java.util.Objects.deepEquals(this.userId, other.userId) &&
            java.util.Objects.deepEquals(this.name, other.name) &&
            java.util.Objects.deepEquals(this.lastSeen, other.lastSeen) &&
            java.util.Objects.deepEquals(this.sourceSegments, other.sourceSegments) &&
            java.util.Objects.deepEquals(this.transcodedSegments, other.transcodedSegments) &&
            java.util.Objects.deepEquals(this.sourceSegmentsDuration, other.sourceSegmentsDuration) &&
            java.util.Objects.deepEquals(this.transcodedSegmentsDuration, other.transcodedSegmentsDuration) &&
            java.util.Objects.deepEquals(this.sourceBytes, other.sourceBytes) &&
            java.util.Objects.deepEquals(this.transcodedBytes, other.transcodedBytes) &&
            java.util.Objects.deepEquals(this.ingestRate, other.ingestRate) &&
            java.util.Objects.deepEquals(this.outgoingRate, other.outgoingRate) &&
            java.util.Objects.deepEquals(this.isHealthy, other.isHealthy) &&
            java.util.Objects.deepEquals(this.issues, other.issues) &&
            java.util.Objects.deepEquals(this.createdAt, other.createdAt) &&
            java.util.Objects.deepEquals(this.parentId, other.parentId) &&
            java.util.Objects.deepEquals(this.record, other.record) &&
            java.util.Objects.deepEquals(this.recordingStatus, other.recordingStatus) &&
            java.util.Objects.deepEquals(this.recordingUrl, other.recordingUrl) &&
            java.util.Objects.deepEquals(this.mp4Url, other.mp4Url) &&
            java.util.Objects.deepEquals(this.playbackId, other.playbackId) &&
            java.util.Objects.deepEquals(this.profiles, other.profiles);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            id,
            kind,
            userId,
            name,
            lastSeen,
            sourceSegments,
            transcodedSegments,
            sourceSegmentsDuration,
            transcodedSegmentsDuration,
            sourceBytes,
            transcodedBytes,
            ingestRate,
            outgoingRate,
            isHealthy,
            issues,
            createdAt,
            parentId,
            record,
            recordingStatus,
            recordingUrl,
            mp4Url,
            playbackId,
            profiles);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Session.class,
                "id", id,
                "kind", kind,
                "userId", userId,
                "name", name,
                "lastSeen", lastSeen,
                "sourceSegments", sourceSegments,
                "transcodedSegments", transcodedSegments,
                "sourceSegmentsDuration", sourceSegmentsDuration,
                "transcodedSegmentsDuration", transcodedSegmentsDuration,
                "sourceBytes", sourceBytes,
                "transcodedBytes", transcodedBytes,
                "ingestRate", ingestRate,
                "outgoingRate", outgoingRate,
                "isHealthy", isHealthy,
                "issues", issues,
                "createdAt", createdAt,
                "parentId", parentId,
                "record", record,
                "recordingStatus", recordingStatus,
                "recordingUrl", recordingUrl,
                "mp4Url", mp4Url,
                "playbackId", playbackId,
                "profiles", profiles);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> id = Optional.empty();
 
        @Deprecated
        private Optional<? extends String> kind = Optional.empty();
 
        @Deprecated
        private Optional<? extends String> userId = Optional.empty();
 
        private String name;
 
        private Optional<? extends Double> lastSeen = Optional.empty();
 
        private Optional<? extends Double> sourceSegments = Optional.empty();
 
        private Optional<? extends Double> transcodedSegments = Optional.empty();
 
        private Optional<? extends Double> sourceSegmentsDuration = Optional.empty();
 
        private Optional<? extends Double> transcodedSegmentsDuration = Optional.empty();
 
        private Optional<? extends Double> sourceBytes = Optional.empty();
 
        private Optional<? extends Double> transcodedBytes = Optional.empty();
 
        private Optional<? extends Double> ingestRate = Optional.empty();
 
        private Optional<? extends Double> outgoingRate = Optional.empty();
 
        private JsonNullable<? extends Boolean> isHealthy = JsonNullable.undefined();
 
        private JsonNullable<? extends java.util.List<String>> issues = JsonNullable.undefined();
 
        private Optional<? extends Double> createdAt = Optional.empty();
 
        private Optional<? extends String> parentId = Optional.empty();
 
        private Optional<? extends Boolean> record = Optional.empty();
 
        private Optional<? extends RecordingStatus> recordingStatus = Optional.empty();
 
        private Optional<? extends String> recordingUrl = Optional.empty();
 
        private Optional<? extends String> mp4Url = Optional.empty();
 
        private Optional<? extends String> playbackId = Optional.empty();
 
        private Optional<? extends java.util.List<FfmpegProfile>> profiles = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<? extends String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(String kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = Optional.ofNullable(kind);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(Optional<? extends String> kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = kind;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(String userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = Optional.ofNullable(userId);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(Optional<? extends String> userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = userId;
            return this;
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        public Builder lastSeen(double lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = Optional.ofNullable(lastSeen);
            return this;
        }

        public Builder lastSeen(Optional<? extends Double> lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = lastSeen;
            return this;
        }

        public Builder sourceSegments(double sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = Optional.ofNullable(sourceSegments);
            return this;
        }

        public Builder sourceSegments(Optional<? extends Double> sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = sourceSegments;
            return this;
        }

        public Builder transcodedSegments(double transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = Optional.ofNullable(transcodedSegments);
            return this;
        }

        public Builder transcodedSegments(Optional<? extends Double> transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = transcodedSegments;
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(double sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(Optional<? extends Double> sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = sourceSegmentsDuration;
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(double transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(Optional<? extends Double> transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = transcodedSegmentsDuration;
            return this;
        }

        public Builder sourceBytes(double sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = Optional.ofNullable(sourceBytes);
            return this;
        }

        public Builder sourceBytes(Optional<? extends Double> sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = sourceBytes;
            return this;
        }

        public Builder transcodedBytes(double transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = Optional.ofNullable(transcodedBytes);
            return this;
        }

        public Builder transcodedBytes(Optional<? extends Double> transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = transcodedBytes;
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(double ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = Optional.ofNullable(ingestRate);
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(Optional<? extends Double> ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = ingestRate;
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(double outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = Optional.ofNullable(outgoingRate);
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(Optional<? extends Double> outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = outgoingRate;
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(boolean isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = JsonNullable.of(isHealthy);
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(JsonNullable<? extends Boolean> isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = isHealthy;
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(java.util.List<String> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = JsonNullable.of(issues);
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(JsonNullable<? extends java.util.List<String>> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = issues;
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(double createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(Optional<? extends Double> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(String parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = Optional.ofNullable(parentId);
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(Optional<? extends String> parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = parentId;
            return this;
        }

        /**
         * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
         * 
         */
        public Builder record(boolean record) {
            Utils.checkNotNull(record, "record");
            this.record = Optional.ofNullable(record);
            return this;
        }

        /**
         * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
         * 
         */
        public Builder record(Optional<? extends Boolean> record) {
            Utils.checkNotNull(record, "record");
            this.record = record;
            return this;
        }

        /**
         * The status of the recording process of this stream session.
         */
        public Builder recordingStatus(RecordingStatus recordingStatus) {
            Utils.checkNotNull(recordingStatus, "recordingStatus");
            this.recordingStatus = Optional.ofNullable(recordingStatus);
            return this;
        }

        /**
         * The status of the recording process of this stream session.
         */
        public Builder recordingStatus(Optional<? extends RecordingStatus> recordingStatus) {
            Utils.checkNotNull(recordingStatus, "recordingStatus");
            this.recordingStatus = recordingStatus;
            return this;
        }

        /**
         * URL for accessing the recording of this stream session.
         */
        public Builder recordingUrl(String recordingUrl) {
            Utils.checkNotNull(recordingUrl, "recordingUrl");
            this.recordingUrl = Optional.ofNullable(recordingUrl);
            return this;
        }

        /**
         * URL for accessing the recording of this stream session.
         */
        public Builder recordingUrl(Optional<? extends String> recordingUrl) {
            Utils.checkNotNull(recordingUrl, "recordingUrl");
            this.recordingUrl = recordingUrl;
            return this;
        }

        /**
         * The URL for the stream session recording packaged in an MP4.
         */
        public Builder mp4Url(String mp4Url) {
            Utils.checkNotNull(mp4Url, "mp4Url");
            this.mp4Url = Optional.ofNullable(mp4Url);
            return this;
        }

        /**
         * The URL for the stream session recording packaged in an MP4.
         */
        public Builder mp4Url(Optional<? extends String> mp4Url) {
            Utils.checkNotNull(mp4Url, "mp4Url");
            this.mp4Url = mp4Url;
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = Optional.ofNullable(playbackId);
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(Optional<? extends String> playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        public Builder profiles(java.util.List<FfmpegProfile> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = Optional.ofNullable(profiles);
            return this;
        }

        public Builder profiles(Optional<? extends java.util.List<FfmpegProfile>> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = profiles;
            return this;
        }
        
        public Session build() {
            return new Session(
                id,
                kind,
                userId,
                name,
                lastSeen,
                sourceSegments,
                transcodedSegments,
                sourceSegmentsDuration,
                transcodedSegmentsDuration,
                sourceBytes,
                transcodedBytes,
                ingestRate,
                outgoingRate,
                isHealthy,
                issues,
                createdAt,
                parentId,
                record,
                recordingStatus,
                recordingUrl,
                mp4Url,
                playbackId,
                profiles);
        }
    }
}

