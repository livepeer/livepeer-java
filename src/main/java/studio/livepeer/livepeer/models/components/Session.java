/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Deprecated;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
import studio.livepeer.livepeer.utils.Utils;


public class Session {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kind")
    @Deprecated
    private Optional<String> kind;

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userId")
    @Deprecated
    private Optional<String> userId;

    @JsonProperty("name")
    private String name;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastSeen")
    private Optional<Double> lastSeen;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegments")
    private Optional<Double> sourceSegments;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegments")
    private Optional<Double> transcodedSegments;

    /**
     * Duration of all the source segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceSegmentsDuration")
    private Optional<Double> sourceSegmentsDuration;

    /**
     * Duration of all the transcoded segments, sec
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedSegmentsDuration")
    private Optional<Double> transcodedSegmentsDuration;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceBytes")
    private Optional<Double> sourceBytes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transcodedBytes")
    private Optional<Double> transcodedBytes;

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ingestRate")
    private Optional<Double> ingestRate;

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("outgoingRate")
    private Optional<Double> outgoingRate;

    /**
     * Indicates whether the stream is healthy or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isHealthy")
    private JsonNullable<Boolean> isHealthy;

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issues")
    private JsonNullable<? extends List<String>> issues;

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<Double> createdAt;

    /**
     * Points to parent stream object
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentId")
    private Optional<String> parentId;

    /**
     * The ID of the project
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("projectId")
    private Optional<String> projectId;

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("record")
    private Optional<Boolean> record;

    /**
     * The status of the recording process of this stream session.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingStatus")
    private Optional<? extends RecordingStatus> recordingStatus;

    /**
     * URL for accessing the recording of this stream session.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingUrl")
    private Optional<String> recordingUrl;

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mp4Url")
    private Optional<String> mp4Url;

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackId")
    private Optional<String> playbackId;

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profiles")
    private Optional<? extends List<FfmpegProfile>> profiles;

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingSpec")
    private Optional<? extends RecordingSpec> recordingSpec;

    @JsonCreator
    public Session(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("kind") Optional<String> kind,
            @JsonProperty("userId") Optional<String> userId,
            @JsonProperty("name") String name,
            @JsonProperty("lastSeen") Optional<Double> lastSeen,
            @JsonProperty("sourceSegments") Optional<Double> sourceSegments,
            @JsonProperty("transcodedSegments") Optional<Double> transcodedSegments,
            @JsonProperty("sourceSegmentsDuration") Optional<Double> sourceSegmentsDuration,
            @JsonProperty("transcodedSegmentsDuration") Optional<Double> transcodedSegmentsDuration,
            @JsonProperty("sourceBytes") Optional<Double> sourceBytes,
            @JsonProperty("transcodedBytes") Optional<Double> transcodedBytes,
            @JsonProperty("ingestRate") Optional<Double> ingestRate,
            @JsonProperty("outgoingRate") Optional<Double> outgoingRate,
            @JsonProperty("isHealthy") JsonNullable<Boolean> isHealthy,
            @JsonProperty("issues") JsonNullable<? extends List<String>> issues,
            @JsonProperty("createdAt") Optional<Double> createdAt,
            @JsonProperty("parentId") Optional<String> parentId,
            @JsonProperty("projectId") Optional<String> projectId,
            @JsonProperty("record") Optional<Boolean> record,
            @JsonProperty("recordingStatus") Optional<? extends RecordingStatus> recordingStatus,
            @JsonProperty("recordingUrl") Optional<String> recordingUrl,
            @JsonProperty("mp4Url") Optional<String> mp4Url,
            @JsonProperty("playbackId") Optional<String> playbackId,
            @JsonProperty("profiles") Optional<? extends List<FfmpegProfile>> profiles,
            @JsonProperty("recordingSpec") Optional<? extends RecordingSpec> recordingSpec) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(kind, "kind");
        Utils.checkNotNull(userId, "userId");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(lastSeen, "lastSeen");
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        Utils.checkNotNull(ingestRate, "ingestRate");
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        Utils.checkNotNull(isHealthy, "isHealthy");
        Utils.checkNotNull(issues, "issues");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(parentId, "parentId");
        Utils.checkNotNull(projectId, "projectId");
        Utils.checkNotNull(record, "record");
        Utils.checkNotNull(recordingStatus, "recordingStatus");
        Utils.checkNotNull(recordingUrl, "recordingUrl");
        Utils.checkNotNull(mp4Url, "mp4Url");
        Utils.checkNotNull(playbackId, "playbackId");
        Utils.checkNotNull(profiles, "profiles");
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.id = id;
        this.kind = kind;
        this.userId = userId;
        this.name = name;
        this.lastSeen = lastSeen;
        this.sourceSegments = sourceSegments;
        this.transcodedSegments = transcodedSegments;
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        this.sourceBytes = sourceBytes;
        this.transcodedBytes = transcodedBytes;
        this.ingestRate = ingestRate;
        this.outgoingRate = outgoingRate;
        this.isHealthy = isHealthy;
        this.issues = issues;
        this.createdAt = createdAt;
        this.parentId = parentId;
        this.projectId = projectId;
        this.record = record;
        this.recordingStatus = recordingStatus;
        this.recordingUrl = recordingUrl;
        this.mp4Url = mp4Url;
        this.playbackId = playbackId;
        this.profiles = profiles;
        this.recordingSpec = recordingSpec;
    }
    
    public Session(
            String name) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), name, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @JsonIgnore
    public Optional<String> kind() {
        return kind;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @JsonIgnore
    public Optional<String> userId() {
        return userId;
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    @JsonIgnore
    public Optional<Double> lastSeen() {
        return lastSeen;
    }

    @JsonIgnore
    public Optional<Double> sourceSegments() {
        return sourceSegments;
    }

    @JsonIgnore
    public Optional<Double> transcodedSegments() {
        return transcodedSegments;
    }

    /**
     * Duration of all the source segments, sec
     */
    @JsonIgnore
    public Optional<Double> sourceSegmentsDuration() {
        return sourceSegmentsDuration;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    @JsonIgnore
    public Optional<Double> transcodedSegmentsDuration() {
        return transcodedSegmentsDuration;
    }

    @JsonIgnore
    public Optional<Double> sourceBytes() {
        return sourceBytes;
    }

    @JsonIgnore
    public Optional<Double> transcodedBytes() {
        return transcodedBytes;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    @JsonIgnore
    public Optional<Double> ingestRate() {
        return ingestRate;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    @JsonIgnore
    public Optional<Double> outgoingRate() {
        return outgoingRate;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isHealthy() {
        return isHealthy;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<String>> issues() {
        return (JsonNullable<List<String>>) issues;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    @JsonIgnore
    public Optional<Double> createdAt() {
        return createdAt;
    }

    /**
     * Points to parent stream object
     */
    @JsonIgnore
    public Optional<String> parentId() {
        return parentId;
    }

    /**
     * The ID of the project
     */
    @JsonIgnore
    public Optional<String> projectId() {
        return projectId;
    }

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    @JsonIgnore
    public Optional<Boolean> record() {
        return record;
    }

    /**
     * The status of the recording process of this stream session.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<RecordingStatus> recordingStatus() {
        return (Optional<RecordingStatus>) recordingStatus;
    }

    /**
     * URL for accessing the recording of this stream session.
     */
    @JsonIgnore
    public Optional<String> recordingUrl() {
        return recordingUrl;
    }

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    @JsonIgnore
    public Optional<String> mp4Url() {
        return mp4Url;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    @JsonIgnore
    public Optional<String> playbackId() {
        return playbackId;
    }

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FfmpegProfile>> profiles() {
        return (Optional<List<FfmpegProfile>>) profiles;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<RecordingSpec> recordingSpec() {
        return (Optional<RecordingSpec>) recordingSpec;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public Session withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    public Session withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withKind(String kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = Optional.ofNullable(kind);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withKind(Optional<String> kind) {
        Utils.checkNotNull(kind, "kind");
        this.kind = kind;
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withUserId(String userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = Optional.ofNullable(userId);
        return this;
    }

    /**
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public Session withUserId(Optional<String> userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = userId;
        return this;
    }

    public Session withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    public Session withLastSeen(double lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = Optional.ofNullable(lastSeen);
        return this;
    }

    public Session withLastSeen(Optional<Double> lastSeen) {
        Utils.checkNotNull(lastSeen, "lastSeen");
        this.lastSeen = lastSeen;
        return this;
    }

    public Session withSourceSegments(double sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = Optional.ofNullable(sourceSegments);
        return this;
    }

    public Session withSourceSegments(Optional<Double> sourceSegments) {
        Utils.checkNotNull(sourceSegments, "sourceSegments");
        this.sourceSegments = sourceSegments;
        return this;
    }

    public Session withTranscodedSegments(double transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = Optional.ofNullable(transcodedSegments);
        return this;
    }

    public Session withTranscodedSegments(Optional<Double> transcodedSegments) {
        Utils.checkNotNull(transcodedSegments, "transcodedSegments");
        this.transcodedSegments = transcodedSegments;
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Session withSourceSegmentsDuration(double sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the source segments, sec
     */
    public Session withSourceSegmentsDuration(Optional<Double> sourceSegmentsDuration) {
        Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
        this.sourceSegmentsDuration = sourceSegmentsDuration;
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Session withTranscodedSegmentsDuration(double transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
        return this;
    }

    /**
     * Duration of all the transcoded segments, sec
     */
    public Session withTranscodedSegmentsDuration(Optional<Double> transcodedSegmentsDuration) {
        Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
        this.transcodedSegmentsDuration = transcodedSegmentsDuration;
        return this;
    }

    public Session withSourceBytes(double sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = Optional.ofNullable(sourceBytes);
        return this;
    }

    public Session withSourceBytes(Optional<Double> sourceBytes) {
        Utils.checkNotNull(sourceBytes, "sourceBytes");
        this.sourceBytes = sourceBytes;
        return this;
    }

    public Session withTranscodedBytes(double transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = Optional.ofNullable(transcodedBytes);
        return this;
    }

    public Session withTranscodedBytes(Optional<Double> transcodedBytes) {
        Utils.checkNotNull(transcodedBytes, "transcodedBytes");
        this.transcodedBytes = transcodedBytes;
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Session withIngestRate(double ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = Optional.ofNullable(ingestRate);
        return this;
    }

    /**
     * Rate at which sourceBytes increases (bytes/second)
     */
    public Session withIngestRate(Optional<Double> ingestRate) {
        Utils.checkNotNull(ingestRate, "ingestRate");
        this.ingestRate = ingestRate;
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Session withOutgoingRate(double outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = Optional.ofNullable(outgoingRate);
        return this;
    }

    /**
     * Rate at which transcodedBytes increases (bytes/second)
     */
    public Session withOutgoingRate(Optional<Double> outgoingRate) {
        Utils.checkNotNull(outgoingRate, "outgoingRate");
        this.outgoingRate = outgoingRate;
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Session withIsHealthy(boolean isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = JsonNullable.of(isHealthy);
        return this;
    }

    /**
     * Indicates whether the stream is healthy or not.
     */
    public Session withIsHealthy(JsonNullable<Boolean> isHealthy) {
        Utils.checkNotNull(isHealthy, "isHealthy");
        this.isHealthy = isHealthy;
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Session withIssues(List<String> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = JsonNullable.of(issues);
        return this;
    }

    /**
     * A string array of human-readable errors describing issues affecting the stream, if any.
     */
    public Session withIssues(JsonNullable<? extends List<String>> issues) {
        Utils.checkNotNull(issues, "issues");
        this.issues = issues;
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Session withCreatedAt(double createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Timestamp (in milliseconds) at which stream object was created
     */
    public Session withCreatedAt(Optional<Double> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Session withParentId(String parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = Optional.ofNullable(parentId);
        return this;
    }

    /**
     * Points to parent stream object
     */
    public Session withParentId(Optional<String> parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = parentId;
        return this;
    }

    /**
     * The ID of the project
     */
    public Session withProjectId(String projectId) {
        Utils.checkNotNull(projectId, "projectId");
        this.projectId = Optional.ofNullable(projectId);
        return this;
    }

    /**
     * The ID of the project
     */
    public Session withProjectId(Optional<String> projectId) {
        Utils.checkNotNull(projectId, "projectId");
        this.projectId = projectId;
        return this;
    }

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    public Session withRecord(boolean record) {
        Utils.checkNotNull(record, "record");
        this.record = Optional.ofNullable(record);
        return this;
    }

    /**
     * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
     * 
     */
    public Session withRecord(Optional<Boolean> record) {
        Utils.checkNotNull(record, "record");
        this.record = record;
        return this;
    }

    /**
     * The status of the recording process of this stream session.
     */
    public Session withRecordingStatus(RecordingStatus recordingStatus) {
        Utils.checkNotNull(recordingStatus, "recordingStatus");
        this.recordingStatus = Optional.ofNullable(recordingStatus);
        return this;
    }

    /**
     * The status of the recording process of this stream session.
     */
    public Session withRecordingStatus(Optional<? extends RecordingStatus> recordingStatus) {
        Utils.checkNotNull(recordingStatus, "recordingStatus");
        this.recordingStatus = recordingStatus;
        return this;
    }

    /**
     * URL for accessing the recording of this stream session.
     */
    public Session withRecordingUrl(String recordingUrl) {
        Utils.checkNotNull(recordingUrl, "recordingUrl");
        this.recordingUrl = Optional.ofNullable(recordingUrl);
        return this;
    }

    /**
     * URL for accessing the recording of this stream session.
     */
    public Session withRecordingUrl(Optional<String> recordingUrl) {
        Utils.checkNotNull(recordingUrl, "recordingUrl");
        this.recordingUrl = recordingUrl;
        return this;
    }

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    public Session withMp4Url(String mp4Url) {
        Utils.checkNotNull(mp4Url, "mp4Url");
        this.mp4Url = Optional.ofNullable(mp4Url);
        return this;
    }

    /**
     * The URL for the stream session recording packaged in an MP4.
     */
    public Session withMp4Url(Optional<String> mp4Url) {
        Utils.checkNotNull(mp4Url, "mp4Url");
        this.mp4Url = mp4Url;
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Session withPlaybackId(String playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = Optional.ofNullable(playbackId);
        return this;
    }

    /**
     * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
     */
    public Session withPlaybackId(Optional<String> playbackId) {
        Utils.checkNotNull(playbackId, "playbackId");
        this.playbackId = playbackId;
        return this;
    }

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    public Session withProfiles(List<FfmpegProfile> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = Optional.ofNullable(profiles);
        return this;
    }

    /**
     * Profiles to transcode the stream into. If not specified, a default
     * set of profiles will be used with 240p, 360p, 480p and 720p
     * resolutions. Keep in mind that the source rendition is always kept.
     * 
     */
    public Session withProfiles(Optional<? extends List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = profiles;
        return this;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    public Session withRecordingSpec(RecordingSpec recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = Optional.ofNullable(recordingSpec);
        return this;
    }

    /**
     * Configuration for recording the stream. This can only be set if
     * `record` is true.
     * 
     */
    public Session withRecordingSpec(Optional<? extends RecordingSpec> recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = recordingSpec;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Session other = (Session) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.kind, other.kind) &&
            Objects.deepEquals(this.userId, other.userId) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.lastSeen, other.lastSeen) &&
            Objects.deepEquals(this.sourceSegments, other.sourceSegments) &&
            Objects.deepEquals(this.transcodedSegments, other.transcodedSegments) &&
            Objects.deepEquals(this.sourceSegmentsDuration, other.sourceSegmentsDuration) &&
            Objects.deepEquals(this.transcodedSegmentsDuration, other.transcodedSegmentsDuration) &&
            Objects.deepEquals(this.sourceBytes, other.sourceBytes) &&
            Objects.deepEquals(this.transcodedBytes, other.transcodedBytes) &&
            Objects.deepEquals(this.ingestRate, other.ingestRate) &&
            Objects.deepEquals(this.outgoingRate, other.outgoingRate) &&
            Objects.deepEquals(this.isHealthy, other.isHealthy) &&
            Objects.deepEquals(this.issues, other.issues) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.parentId, other.parentId) &&
            Objects.deepEquals(this.projectId, other.projectId) &&
            Objects.deepEquals(this.record, other.record) &&
            Objects.deepEquals(this.recordingStatus, other.recordingStatus) &&
            Objects.deepEquals(this.recordingUrl, other.recordingUrl) &&
            Objects.deepEquals(this.mp4Url, other.mp4Url) &&
            Objects.deepEquals(this.playbackId, other.playbackId) &&
            Objects.deepEquals(this.profiles, other.profiles) &&
            Objects.deepEquals(this.recordingSpec, other.recordingSpec);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            kind,
            userId,
            name,
            lastSeen,
            sourceSegments,
            transcodedSegments,
            sourceSegmentsDuration,
            transcodedSegmentsDuration,
            sourceBytes,
            transcodedBytes,
            ingestRate,
            outgoingRate,
            isHealthy,
            issues,
            createdAt,
            parentId,
            projectId,
            record,
            recordingStatus,
            recordingUrl,
            mp4Url,
            playbackId,
            profiles,
            recordingSpec);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Session.class,
                "id", id,
                "kind", kind,
                "userId", userId,
                "name", name,
                "lastSeen", lastSeen,
                "sourceSegments", sourceSegments,
                "transcodedSegments", transcodedSegments,
                "sourceSegmentsDuration", sourceSegmentsDuration,
                "transcodedSegmentsDuration", transcodedSegmentsDuration,
                "sourceBytes", sourceBytes,
                "transcodedBytes", transcodedBytes,
                "ingestRate", ingestRate,
                "outgoingRate", outgoingRate,
                "isHealthy", isHealthy,
                "issues", issues,
                "createdAt", createdAt,
                "parentId", parentId,
                "projectId", projectId,
                "record", record,
                "recordingStatus", recordingStatus,
                "recordingUrl", recordingUrl,
                "mp4Url", mp4Url,
                "playbackId", playbackId,
                "profiles", profiles,
                "recordingSpec", recordingSpec);
    }
    
    public final static class Builder {
 
        private Optional<String> id = Optional.empty();
 
        @Deprecated
        private Optional<String> kind = Optional.empty();
 
        @Deprecated
        private Optional<String> userId = Optional.empty();
 
        private String name;
 
        private Optional<Double> lastSeen = Optional.empty();
 
        private Optional<Double> sourceSegments = Optional.empty();
 
        private Optional<Double> transcodedSegments = Optional.empty();
 
        private Optional<Double> sourceSegmentsDuration = Optional.empty();
 
        private Optional<Double> transcodedSegmentsDuration = Optional.empty();
 
        private Optional<Double> sourceBytes = Optional.empty();
 
        private Optional<Double> transcodedBytes = Optional.empty();
 
        private Optional<Double> ingestRate = Optional.empty();
 
        private Optional<Double> outgoingRate = Optional.empty();
 
        private JsonNullable<Boolean> isHealthy = JsonNullable.undefined();
 
        private JsonNullable<? extends List<String>> issues = JsonNullable.undefined();
 
        private Optional<Double> createdAt = Optional.empty();
 
        private Optional<String> parentId = Optional.empty();
 
        private Optional<String> projectId = Optional.empty();
 
        private Optional<Boolean> record = Optional.empty();
 
        private Optional<? extends RecordingStatus> recordingStatus = Optional.empty();
 
        private Optional<String> recordingUrl = Optional.empty();
 
        private Optional<String> mp4Url = Optional.empty();
 
        private Optional<String> playbackId = Optional.empty();
 
        private Optional<? extends List<FfmpegProfile>> profiles = Optional.empty();
 
        private Optional<? extends RecordingSpec> recordingSpec = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(String kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = Optional.ofNullable(kind);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder kind(Optional<String> kind) {
            Utils.checkNotNull(kind, "kind");
            this.kind = kind;
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(String userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = Optional.ofNullable(userId);
            return this;
        }

        /**
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder userId(Optional<String> userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = userId;
            return this;
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        public Builder lastSeen(double lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = Optional.ofNullable(lastSeen);
            return this;
        }

        public Builder lastSeen(Optional<Double> lastSeen) {
            Utils.checkNotNull(lastSeen, "lastSeen");
            this.lastSeen = lastSeen;
            return this;
        }

        public Builder sourceSegments(double sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = Optional.ofNullable(sourceSegments);
            return this;
        }

        public Builder sourceSegments(Optional<Double> sourceSegments) {
            Utils.checkNotNull(sourceSegments, "sourceSegments");
            this.sourceSegments = sourceSegments;
            return this;
        }

        public Builder transcodedSegments(double transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = Optional.ofNullable(transcodedSegments);
            return this;
        }

        public Builder transcodedSegments(Optional<Double> transcodedSegments) {
            Utils.checkNotNull(transcodedSegments, "transcodedSegments");
            this.transcodedSegments = transcodedSegments;
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(double sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = Optional.ofNullable(sourceSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the source segments, sec
         */
        public Builder sourceSegmentsDuration(Optional<Double> sourceSegmentsDuration) {
            Utils.checkNotNull(sourceSegmentsDuration, "sourceSegmentsDuration");
            this.sourceSegmentsDuration = sourceSegmentsDuration;
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(double transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = Optional.ofNullable(transcodedSegmentsDuration);
            return this;
        }

        /**
         * Duration of all the transcoded segments, sec
         */
        public Builder transcodedSegmentsDuration(Optional<Double> transcodedSegmentsDuration) {
            Utils.checkNotNull(transcodedSegmentsDuration, "transcodedSegmentsDuration");
            this.transcodedSegmentsDuration = transcodedSegmentsDuration;
            return this;
        }

        public Builder sourceBytes(double sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = Optional.ofNullable(sourceBytes);
            return this;
        }

        public Builder sourceBytes(Optional<Double> sourceBytes) {
            Utils.checkNotNull(sourceBytes, "sourceBytes");
            this.sourceBytes = sourceBytes;
            return this;
        }

        public Builder transcodedBytes(double transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = Optional.ofNullable(transcodedBytes);
            return this;
        }

        public Builder transcodedBytes(Optional<Double> transcodedBytes) {
            Utils.checkNotNull(transcodedBytes, "transcodedBytes");
            this.transcodedBytes = transcodedBytes;
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(double ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = Optional.ofNullable(ingestRate);
            return this;
        }

        /**
         * Rate at which sourceBytes increases (bytes/second)
         */
        public Builder ingestRate(Optional<Double> ingestRate) {
            Utils.checkNotNull(ingestRate, "ingestRate");
            this.ingestRate = ingestRate;
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(double outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = Optional.ofNullable(outgoingRate);
            return this;
        }

        /**
         * Rate at which transcodedBytes increases (bytes/second)
         */
        public Builder outgoingRate(Optional<Double> outgoingRate) {
            Utils.checkNotNull(outgoingRate, "outgoingRate");
            this.outgoingRate = outgoingRate;
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(boolean isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = JsonNullable.of(isHealthy);
            return this;
        }

        /**
         * Indicates whether the stream is healthy or not.
         */
        public Builder isHealthy(JsonNullable<Boolean> isHealthy) {
            Utils.checkNotNull(isHealthy, "isHealthy");
            this.isHealthy = isHealthy;
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(List<String> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = JsonNullable.of(issues);
            return this;
        }

        /**
         * A string array of human-readable errors describing issues affecting the stream, if any.
         */
        public Builder issues(JsonNullable<? extends List<String>> issues) {
            Utils.checkNotNull(issues, "issues");
            this.issues = issues;
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(double createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Timestamp (in milliseconds) at which stream object was created
         */
        public Builder createdAt(Optional<Double> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(String parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = Optional.ofNullable(parentId);
            return this;
        }

        /**
         * Points to parent stream object
         */
        public Builder parentId(Optional<String> parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = parentId;
            return this;
        }

        /**
         * The ID of the project
         */
        public Builder projectId(String projectId) {
            Utils.checkNotNull(projectId, "projectId");
            this.projectId = Optional.ofNullable(projectId);
            return this;
        }

        /**
         * The ID of the project
         */
        public Builder projectId(Optional<String> projectId) {
            Utils.checkNotNull(projectId, "projectId");
            this.projectId = projectId;
            return this;
        }

        /**
         * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
         * 
         */
        public Builder record(boolean record) {
            Utils.checkNotNull(record, "record");
            this.record = Optional.ofNullable(record);
            return this;
        }

        /**
         * Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.
         * 
         */
        public Builder record(Optional<Boolean> record) {
            Utils.checkNotNull(record, "record");
            this.record = record;
            return this;
        }

        /**
         * The status of the recording process of this stream session.
         */
        public Builder recordingStatus(RecordingStatus recordingStatus) {
            Utils.checkNotNull(recordingStatus, "recordingStatus");
            this.recordingStatus = Optional.ofNullable(recordingStatus);
            return this;
        }

        /**
         * The status of the recording process of this stream session.
         */
        public Builder recordingStatus(Optional<? extends RecordingStatus> recordingStatus) {
            Utils.checkNotNull(recordingStatus, "recordingStatus");
            this.recordingStatus = recordingStatus;
            return this;
        }

        /**
         * URL for accessing the recording of this stream session.
         */
        public Builder recordingUrl(String recordingUrl) {
            Utils.checkNotNull(recordingUrl, "recordingUrl");
            this.recordingUrl = Optional.ofNullable(recordingUrl);
            return this;
        }

        /**
         * URL for accessing the recording of this stream session.
         */
        public Builder recordingUrl(Optional<String> recordingUrl) {
            Utils.checkNotNull(recordingUrl, "recordingUrl");
            this.recordingUrl = recordingUrl;
            return this;
        }

        /**
         * The URL for the stream session recording packaged in an MP4.
         */
        public Builder mp4Url(String mp4Url) {
            Utils.checkNotNull(mp4Url, "mp4Url");
            this.mp4Url = Optional.ofNullable(mp4Url);
            return this;
        }

        /**
         * The URL for the stream session recording packaged in an MP4.
         */
        public Builder mp4Url(Optional<String> mp4Url) {
            Utils.checkNotNull(mp4Url, "mp4Url");
            this.mp4Url = mp4Url;
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(String playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = Optional.ofNullable(playbackId);
            return this;
        }

        /**
         * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
         */
        public Builder playbackId(Optional<String> playbackId) {
            Utils.checkNotNull(playbackId, "playbackId");
            this.playbackId = playbackId;
            return this;
        }

        /**
         * Profiles to transcode the stream into. If not specified, a default
         * set of profiles will be used with 240p, 360p, 480p and 720p
         * resolutions. Keep in mind that the source rendition is always kept.
         * 
         */
        public Builder profiles(List<FfmpegProfile> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = Optional.ofNullable(profiles);
            return this;
        }

        /**
         * Profiles to transcode the stream into. If not specified, a default
         * set of profiles will be used with 240p, 360p, 480p and 720p
         * resolutions. Keep in mind that the source rendition is always kept.
         * 
         */
        public Builder profiles(Optional<? extends List<FfmpegProfile>> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = profiles;
            return this;
        }

        /**
         * Configuration for recording the stream. This can only be set if
         * `record` is true.
         * 
         */
        public Builder recordingSpec(RecordingSpec recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = Optional.ofNullable(recordingSpec);
            return this;
        }

        /**
         * Configuration for recording the stream. This can only be set if
         * `record` is true.
         * 
         */
        public Builder recordingSpec(Optional<? extends RecordingSpec> recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = recordingSpec;
            return this;
        }
        
        public Session build() {
            return new Session(
                id,
                kind,
                userId,
                name,
                lastSeen,
                sourceSegments,
                transcodedSegments,
                sourceSegmentsDuration,
                transcodedSegmentsDuration,
                sourceBytes,
                transcodedBytes,
                ingestRate,
                outgoingRate,
                isHealthy,
                issues,
                createdAt,
                parentId,
                projectId,
                record,
                recordingStatus,
                recordingUrl,
                mp4Url,
                playbackId,
                profiles,
                recordingSpec);
        }
    }
}

