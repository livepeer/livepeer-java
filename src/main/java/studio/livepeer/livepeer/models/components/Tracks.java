/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import studio.livepeer.livepeer.utils.Utils;

public class Tracks {

    /**
     * type of track
     */
    @JsonProperty("type")
    private AssetVideoSpecType type;

    /**
     * Codec of the track
     */
    @JsonProperty("codec")
    private String codec;

    /**
     * Start time of the track in seconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("startTime")
    private Optional<? extends Double> startTime;

    /**
     * Duration of the track in seconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<? extends Double> duration;

    /**
     * Bitrate of the track in bits per second
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bitrate")
    private Optional<? extends Double> bitrate;

    /**
     * Width of the track - only for video tracks
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("width")
    private Optional<? extends Double> width;

    /**
     * Height of the track - only for video tracks
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("height")
    private Optional<? extends Double> height;

    /**
     * Pixel format of the track - only for video tracks
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pixelFormat")
    private Optional<? extends String> pixelFormat;

    /**
     * Frame rate of the track - only for video tracks
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fps")
    private Optional<? extends Double> fps;

    /**
     * Amount of audio channels in the track
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("channels")
    private Optional<? extends Double> channels;

    /**
     * Sample rate of the track in samples per second - only for
     * audio tracks
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sampleRate")
    private Optional<? extends Double> sampleRate;

    /**
     * Bit depth of the track - only for audio tracks
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bitDepth")
    private Optional<? extends Double> bitDepth;

    @JsonCreator
    public Tracks(
            @JsonProperty("type") AssetVideoSpecType type,
            @JsonProperty("codec") String codec,
            @JsonProperty("startTime") Optional<? extends Double> startTime,
            @JsonProperty("duration") Optional<? extends Double> duration,
            @JsonProperty("bitrate") Optional<? extends Double> bitrate,
            @JsonProperty("width") Optional<? extends Double> width,
            @JsonProperty("height") Optional<? extends Double> height,
            @JsonProperty("pixelFormat") Optional<? extends String> pixelFormat,
            @JsonProperty("fps") Optional<? extends Double> fps,
            @JsonProperty("channels") Optional<? extends Double> channels,
            @JsonProperty("sampleRate") Optional<? extends Double> sampleRate,
            @JsonProperty("bitDepth") Optional<? extends Double> bitDepth) {
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(codec, "codec");
        Utils.checkNotNull(startTime, "startTime");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(bitrate, "bitrate");
        Utils.checkNotNull(width, "width");
        Utils.checkNotNull(height, "height");
        Utils.checkNotNull(pixelFormat, "pixelFormat");
        Utils.checkNotNull(fps, "fps");
        Utils.checkNotNull(channels, "channels");
        Utils.checkNotNull(sampleRate, "sampleRate");
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.type = type;
        this.codec = codec;
        this.startTime = startTime;
        this.duration = duration;
        this.bitrate = bitrate;
        this.width = width;
        this.height = height;
        this.pixelFormat = pixelFormat;
        this.fps = fps;
        this.channels = channels;
        this.sampleRate = sampleRate;
        this.bitDepth = bitDepth;
    }
    
    public Tracks(
            AssetVideoSpecType type,
            String codec) {
        this(type, codec, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * type of track
     */
    @JsonIgnore
    public AssetVideoSpecType type() {
        return type;
    }

    /**
     * Codec of the track
     */
    @JsonIgnore
    public String codec() {
        return codec;
    }

    /**
     * Start time of the track in seconds
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> startTime() {
        return (Optional<Double>) startTime;
    }

    /**
     * Duration of the track in seconds
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> duration() {
        return (Optional<Double>) duration;
    }

    /**
     * Bitrate of the track in bits per second
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> bitrate() {
        return (Optional<Double>) bitrate;
    }

    /**
     * Width of the track - only for video tracks
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> width() {
        return (Optional<Double>) width;
    }

    /**
     * Height of the track - only for video tracks
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> height() {
        return (Optional<Double>) height;
    }

    /**
     * Pixel format of the track - only for video tracks
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> pixelFormat() {
        return (Optional<String>) pixelFormat;
    }

    /**
     * Frame rate of the track - only for video tracks
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> fps() {
        return (Optional<Double>) fps;
    }

    /**
     * Amount of audio channels in the track
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> channels() {
        return (Optional<Double>) channels;
    }

    /**
     * Sample rate of the track in samples per second - only for
     * audio tracks
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> sampleRate() {
        return (Optional<Double>) sampleRate;
    }

    /**
     * Bit depth of the track - only for audio tracks
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> bitDepth() {
        return (Optional<Double>) bitDepth;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * type of track
     */
    public Tracks withType(AssetVideoSpecType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * Codec of the track
     */
    public Tracks withCodec(String codec) {
        Utils.checkNotNull(codec, "codec");
        this.codec = codec;
        return this;
    }

    /**
     * Start time of the track in seconds
     */
    public Tracks withStartTime(double startTime) {
        Utils.checkNotNull(startTime, "startTime");
        this.startTime = Optional.ofNullable(startTime);
        return this;
    }

    /**
     * Start time of the track in seconds
     */
    public Tracks withStartTime(Optional<? extends Double> startTime) {
        Utils.checkNotNull(startTime, "startTime");
        this.startTime = startTime;
        return this;
    }

    /**
     * Duration of the track in seconds
     */
    public Tracks withDuration(double duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }

    /**
     * Duration of the track in seconds
     */
    public Tracks withDuration(Optional<? extends Double> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * Bitrate of the track in bits per second
     */
    public Tracks withBitrate(double bitrate) {
        Utils.checkNotNull(bitrate, "bitrate");
        this.bitrate = Optional.ofNullable(bitrate);
        return this;
    }

    /**
     * Bitrate of the track in bits per second
     */
    public Tracks withBitrate(Optional<? extends Double> bitrate) {
        Utils.checkNotNull(bitrate, "bitrate");
        this.bitrate = bitrate;
        return this;
    }

    /**
     * Width of the track - only for video tracks
     */
    public Tracks withWidth(double width) {
        Utils.checkNotNull(width, "width");
        this.width = Optional.ofNullable(width);
        return this;
    }

    /**
     * Width of the track - only for video tracks
     */
    public Tracks withWidth(Optional<? extends Double> width) {
        Utils.checkNotNull(width, "width");
        this.width = width;
        return this;
    }

    /**
     * Height of the track - only for video tracks
     */
    public Tracks withHeight(double height) {
        Utils.checkNotNull(height, "height");
        this.height = Optional.ofNullable(height);
        return this;
    }

    /**
     * Height of the track - only for video tracks
     */
    public Tracks withHeight(Optional<? extends Double> height) {
        Utils.checkNotNull(height, "height");
        this.height = height;
        return this;
    }

    /**
     * Pixel format of the track - only for video tracks
     */
    public Tracks withPixelFormat(String pixelFormat) {
        Utils.checkNotNull(pixelFormat, "pixelFormat");
        this.pixelFormat = Optional.ofNullable(pixelFormat);
        return this;
    }

    /**
     * Pixel format of the track - only for video tracks
     */
    public Tracks withPixelFormat(Optional<? extends String> pixelFormat) {
        Utils.checkNotNull(pixelFormat, "pixelFormat");
        this.pixelFormat = pixelFormat;
        return this;
    }

    /**
     * Frame rate of the track - only for video tracks
     */
    public Tracks withFps(double fps) {
        Utils.checkNotNull(fps, "fps");
        this.fps = Optional.ofNullable(fps);
        return this;
    }

    /**
     * Frame rate of the track - only for video tracks
     */
    public Tracks withFps(Optional<? extends Double> fps) {
        Utils.checkNotNull(fps, "fps");
        this.fps = fps;
        return this;
    }

    /**
     * Amount of audio channels in the track
     */
    public Tracks withChannels(double channels) {
        Utils.checkNotNull(channels, "channels");
        this.channels = Optional.ofNullable(channels);
        return this;
    }

    /**
     * Amount of audio channels in the track
     */
    public Tracks withChannels(Optional<? extends Double> channels) {
        Utils.checkNotNull(channels, "channels");
        this.channels = channels;
        return this;
    }

    /**
     * Sample rate of the track in samples per second - only for
     * audio tracks
     * 
     */
    public Tracks withSampleRate(double sampleRate) {
        Utils.checkNotNull(sampleRate, "sampleRate");
        this.sampleRate = Optional.ofNullable(sampleRate);
        return this;
    }

    /**
     * Sample rate of the track in samples per second - only for
     * audio tracks
     * 
     */
    public Tracks withSampleRate(Optional<? extends Double> sampleRate) {
        Utils.checkNotNull(sampleRate, "sampleRate");
        this.sampleRate = sampleRate;
        return this;
    }

    /**
     * Bit depth of the track - only for audio tracks
     */
    public Tracks withBitDepth(double bitDepth) {
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.bitDepth = Optional.ofNullable(bitDepth);
        return this;
    }

    /**
     * Bit depth of the track - only for audio tracks
     */
    public Tracks withBitDepth(Optional<? extends Double> bitDepth) {
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.bitDepth = bitDepth;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Tracks other = (Tracks) o;
        return 
            java.util.Objects.deepEquals(this.type, other.type) &&
            java.util.Objects.deepEquals(this.codec, other.codec) &&
            java.util.Objects.deepEquals(this.startTime, other.startTime) &&
            java.util.Objects.deepEquals(this.duration, other.duration) &&
            java.util.Objects.deepEquals(this.bitrate, other.bitrate) &&
            java.util.Objects.deepEquals(this.width, other.width) &&
            java.util.Objects.deepEquals(this.height, other.height) &&
            java.util.Objects.deepEquals(this.pixelFormat, other.pixelFormat) &&
            java.util.Objects.deepEquals(this.fps, other.fps) &&
            java.util.Objects.deepEquals(this.channels, other.channels) &&
            java.util.Objects.deepEquals(this.sampleRate, other.sampleRate) &&
            java.util.Objects.deepEquals(this.bitDepth, other.bitDepth);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            type,
            codec,
            startTime,
            duration,
            bitrate,
            width,
            height,
            pixelFormat,
            fps,
            channels,
            sampleRate,
            bitDepth);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Tracks.class,
                "type", type,
                "codec", codec,
                "startTime", startTime,
                "duration", duration,
                "bitrate", bitrate,
                "width", width,
                "height", height,
                "pixelFormat", pixelFormat,
                "fps", fps,
                "channels", channels,
                "sampleRate", sampleRate,
                "bitDepth", bitDepth);
    }
    
    public final static class Builder {
 
        private AssetVideoSpecType type;
 
        private String codec;
 
        private Optional<? extends Double> startTime = Optional.empty();
 
        private Optional<? extends Double> duration = Optional.empty();
 
        private Optional<? extends Double> bitrate = Optional.empty();
 
        private Optional<? extends Double> width = Optional.empty();
 
        private Optional<? extends Double> height = Optional.empty();
 
        private Optional<? extends String> pixelFormat = Optional.empty();
 
        private Optional<? extends Double> fps = Optional.empty();
 
        private Optional<? extends Double> channels = Optional.empty();
 
        private Optional<? extends Double> sampleRate = Optional.empty();
 
        private Optional<? extends Double> bitDepth = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * type of track
         */
        public Builder type(AssetVideoSpecType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * Codec of the track
         */
        public Builder codec(String codec) {
            Utils.checkNotNull(codec, "codec");
            this.codec = codec;
            return this;
        }

        /**
         * Start time of the track in seconds
         */
        public Builder startTime(double startTime) {
            Utils.checkNotNull(startTime, "startTime");
            this.startTime = Optional.ofNullable(startTime);
            return this;
        }

        /**
         * Start time of the track in seconds
         */
        public Builder startTime(Optional<? extends Double> startTime) {
            Utils.checkNotNull(startTime, "startTime");
            this.startTime = startTime;
            return this;
        }

        /**
         * Duration of the track in seconds
         */
        public Builder duration(double duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * Duration of the track in seconds
         */
        public Builder duration(Optional<? extends Double> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }

        /**
         * Bitrate of the track in bits per second
         */
        public Builder bitrate(double bitrate) {
            Utils.checkNotNull(bitrate, "bitrate");
            this.bitrate = Optional.ofNullable(bitrate);
            return this;
        }

        /**
         * Bitrate of the track in bits per second
         */
        public Builder bitrate(Optional<? extends Double> bitrate) {
            Utils.checkNotNull(bitrate, "bitrate");
            this.bitrate = bitrate;
            return this;
        }

        /**
         * Width of the track - only for video tracks
         */
        public Builder width(double width) {
            Utils.checkNotNull(width, "width");
            this.width = Optional.ofNullable(width);
            return this;
        }

        /**
         * Width of the track - only for video tracks
         */
        public Builder width(Optional<? extends Double> width) {
            Utils.checkNotNull(width, "width");
            this.width = width;
            return this;
        }

        /**
         * Height of the track - only for video tracks
         */
        public Builder height(double height) {
            Utils.checkNotNull(height, "height");
            this.height = Optional.ofNullable(height);
            return this;
        }

        /**
         * Height of the track - only for video tracks
         */
        public Builder height(Optional<? extends Double> height) {
            Utils.checkNotNull(height, "height");
            this.height = height;
            return this;
        }

        /**
         * Pixel format of the track - only for video tracks
         */
        public Builder pixelFormat(String pixelFormat) {
            Utils.checkNotNull(pixelFormat, "pixelFormat");
            this.pixelFormat = Optional.ofNullable(pixelFormat);
            return this;
        }

        /**
         * Pixel format of the track - only for video tracks
         */
        public Builder pixelFormat(Optional<? extends String> pixelFormat) {
            Utils.checkNotNull(pixelFormat, "pixelFormat");
            this.pixelFormat = pixelFormat;
            return this;
        }

        /**
         * Frame rate of the track - only for video tracks
         */
        public Builder fps(double fps) {
            Utils.checkNotNull(fps, "fps");
            this.fps = Optional.ofNullable(fps);
            return this;
        }

        /**
         * Frame rate of the track - only for video tracks
         */
        public Builder fps(Optional<? extends Double> fps) {
            Utils.checkNotNull(fps, "fps");
            this.fps = fps;
            return this;
        }

        /**
         * Amount of audio channels in the track
         */
        public Builder channels(double channels) {
            Utils.checkNotNull(channels, "channels");
            this.channels = Optional.ofNullable(channels);
            return this;
        }

        /**
         * Amount of audio channels in the track
         */
        public Builder channels(Optional<? extends Double> channels) {
            Utils.checkNotNull(channels, "channels");
            this.channels = channels;
            return this;
        }

        /**
         * Sample rate of the track in samples per second - only for
         * audio tracks
         * 
         */
        public Builder sampleRate(double sampleRate) {
            Utils.checkNotNull(sampleRate, "sampleRate");
            this.sampleRate = Optional.ofNullable(sampleRate);
            return this;
        }

        /**
         * Sample rate of the track in samples per second - only for
         * audio tracks
         * 
         */
        public Builder sampleRate(Optional<? extends Double> sampleRate) {
            Utils.checkNotNull(sampleRate, "sampleRate");
            this.sampleRate = sampleRate;
            return this;
        }

        /**
         * Bit depth of the track - only for audio tracks
         */
        public Builder bitDepth(double bitDepth) {
            Utils.checkNotNull(bitDepth, "bitDepth");
            this.bitDepth = Optional.ofNullable(bitDepth);
            return this;
        }

        /**
         * Bit depth of the track - only for audio tracks
         */
        public Builder bitDepth(Optional<? extends Double> bitDepth) {
            Utils.checkNotNull(bitDepth, "bitDepth");
            this.bitDepth = bitDepth;
            return this;
        }
        
        public Tracks build() {
            return new Tracks(
                type,
                codec,
                startTime,
                duration,
                bitrate,
                width,
                height,
                pixelFormat,
                fps,
                channels,
                sampleRate,
                bitDepth);
        }
    }
}

