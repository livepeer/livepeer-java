/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
import studio.livepeer.livepeer.utils.Utils;


public class NewStreamPayload {

    @JsonProperty("name")
    private String name;

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pull")
    private Optional<? extends Pull> pull;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private Optional<? extends InputCreatorId> creatorId;

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackPolicy")
    private JsonNullable<? extends PlaybackPolicy> playbackPolicy;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profiles")
    private JsonNullable<? extends List<FfmpegProfile>> profiles;

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("record")
    private Optional<Boolean> record;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingSpec")
    private Optional<? extends NewStreamPayloadRecordingSpec> recordingSpec;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("multistream")
    private Optional<? extends Multistream> multistream;

    /**
     * User input tags associated with the stream
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userTags")
    private Optional<? extends Map<String, UserTags>> userTags;

    @JsonCreator
    public NewStreamPayload(
            @JsonProperty("name") String name,
            @JsonProperty("pull") Optional<? extends Pull> pull,
            @JsonProperty("creatorId") Optional<? extends InputCreatorId> creatorId,
            @JsonProperty("playbackPolicy") JsonNullable<? extends PlaybackPolicy> playbackPolicy,
            @JsonProperty("profiles") JsonNullable<? extends List<FfmpegProfile>> profiles,
            @JsonProperty("record") Optional<Boolean> record,
            @JsonProperty("recordingSpec") Optional<? extends NewStreamPayloadRecordingSpec> recordingSpec,
            @JsonProperty("multistream") Optional<? extends Multistream> multistream,
            @JsonProperty("userTags") Optional<? extends Map<String, UserTags>> userTags) {
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(pull, "pull");
        Utils.checkNotNull(creatorId, "creatorId");
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        Utils.checkNotNull(profiles, "profiles");
        Utils.checkNotNull(record, "record");
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        Utils.checkNotNull(multistream, "multistream");
        Utils.checkNotNull(userTags, "userTags");
        this.name = name;
        this.pull = pull;
        this.creatorId = creatorId;
        this.playbackPolicy = playbackPolicy;
        this.profiles = profiles;
        this.record = record;
        this.recordingSpec = recordingSpec;
        this.multistream = multistream;
        this.userTags = userTags;
    }
    
    public NewStreamPayload(
            String name) {
        this(name, Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Pull> pull() {
        return (Optional<Pull>) pull;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<InputCreatorId> creatorId() {
        return (Optional<InputCreatorId>) creatorId;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PlaybackPolicy> playbackPolicy() {
        return (JsonNullable<PlaybackPolicy>) playbackPolicy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<FfmpegProfile>> profiles() {
        return (JsonNullable<List<FfmpegProfile>>) profiles;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonIgnore
    public Optional<Boolean> record() {
        return record;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<NewStreamPayloadRecordingSpec> recordingSpec() {
        return (Optional<NewStreamPayloadRecordingSpec>) recordingSpec;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Multistream> multistream() {
        return (Optional<Multistream>) multistream;
    }

    /**
     * User input tags associated with the stream
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, UserTags>> userTags() {
        return (Optional<Map<String, UserTags>>) userTags;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public NewStreamPayload withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    public NewStreamPayload withPull(Pull pull) {
        Utils.checkNotNull(pull, "pull");
        this.pull = Optional.ofNullable(pull);
        return this;
    }

    /**
     * Configuration for a stream that should be actively pulled from an
     * external source, rather than pushed to Livepeer. If specified, the
     * stream will not have a streamKey.
     */
    public NewStreamPayload withPull(Optional<? extends Pull> pull) {
        Utils.checkNotNull(pull, "pull");
        this.pull = pull;
        return this;
    }

    public NewStreamPayload withCreatorId(InputCreatorId creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = Optional.ofNullable(creatorId);
        return this;
    }

    public NewStreamPayload withCreatorId(Optional<? extends InputCreatorId> creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = creatorId;
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public NewStreamPayload withPlaybackPolicy(PlaybackPolicy playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = JsonNullable.of(playbackPolicy);
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public NewStreamPayload withPlaybackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = playbackPolicy;
        return this;
    }

    public NewStreamPayload withProfiles(List<FfmpegProfile> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = JsonNullable.of(profiles);
        return this;
    }

    public NewStreamPayload withProfiles(JsonNullable<? extends List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = profiles;
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public NewStreamPayload withRecord(boolean record) {
        Utils.checkNotNull(record, "record");
        this.record = Optional.ofNullable(record);
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public NewStreamPayload withRecord(Optional<Boolean> record) {
        Utils.checkNotNull(record, "record");
        this.record = record;
        return this;
    }

    public NewStreamPayload withRecordingSpec(NewStreamPayloadRecordingSpec recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = Optional.ofNullable(recordingSpec);
        return this;
    }

    public NewStreamPayload withRecordingSpec(Optional<? extends NewStreamPayloadRecordingSpec> recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = recordingSpec;
        return this;
    }

    public NewStreamPayload withMultistream(Multistream multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = Optional.ofNullable(multistream);
        return this;
    }

    public NewStreamPayload withMultistream(Optional<? extends Multistream> multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = multistream;
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public NewStreamPayload withUserTags(Map<String, UserTags> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = Optional.ofNullable(userTags);
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public NewStreamPayload withUserTags(Optional<? extends Map<String, UserTags>> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = userTags;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        NewStreamPayload other = (NewStreamPayload) o;
        return 
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.pull, other.pull) &&
            Objects.deepEquals(this.creatorId, other.creatorId) &&
            Objects.deepEquals(this.playbackPolicy, other.playbackPolicy) &&
            Objects.deepEquals(this.profiles, other.profiles) &&
            Objects.deepEquals(this.record, other.record) &&
            Objects.deepEquals(this.recordingSpec, other.recordingSpec) &&
            Objects.deepEquals(this.multistream, other.multistream) &&
            Objects.deepEquals(this.userTags, other.userTags);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            name,
            pull,
            creatorId,
            playbackPolicy,
            profiles,
            record,
            recordingSpec,
            multistream,
            userTags);
    }
    
    @Override
    public String toString() {
        return Utils.toString(NewStreamPayload.class,
                "name", name,
                "pull", pull,
                "creatorId", creatorId,
                "playbackPolicy", playbackPolicy,
                "profiles", profiles,
                "record", record,
                "recordingSpec", recordingSpec,
                "multistream", multistream,
                "userTags", userTags);
    }
    
    public final static class Builder {
 
        private String name;
 
        private Optional<? extends Pull> pull = Optional.empty();
 
        private Optional<? extends InputCreatorId> creatorId = Optional.empty();
 
        private JsonNullable<? extends PlaybackPolicy> playbackPolicy = JsonNullable.undefined();
 
        private JsonNullable<? extends List<FfmpegProfile>> profiles = JsonNullable.undefined();
 
        private Optional<Boolean> record = Optional.empty();
 
        private Optional<? extends NewStreamPayloadRecordingSpec> recordingSpec = Optional.empty();
 
        private Optional<? extends Multistream> multistream = Optional.empty();
 
        private Optional<? extends Map<String, UserTags>> userTags = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Configuration for a stream that should be actively pulled from an
         * external source, rather than pushed to Livepeer. If specified, the
         * stream will not have a streamKey.
         */
        public Builder pull(Pull pull) {
            Utils.checkNotNull(pull, "pull");
            this.pull = Optional.ofNullable(pull);
            return this;
        }

        /**
         * Configuration for a stream that should be actively pulled from an
         * external source, rather than pushed to Livepeer. If specified, the
         * stream will not have a streamKey.
         */
        public Builder pull(Optional<? extends Pull> pull) {
            Utils.checkNotNull(pull, "pull");
            this.pull = pull;
            return this;
        }

        public Builder creatorId(InputCreatorId creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = Optional.ofNullable(creatorId);
            return this;
        }

        public Builder creatorId(Optional<? extends InputCreatorId> creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = creatorId;
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(PlaybackPolicy playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = JsonNullable.of(playbackPolicy);
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = playbackPolicy;
            return this;
        }

        public Builder profiles(List<FfmpegProfile> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = JsonNullable.of(profiles);
            return this;
        }

        public Builder profiles(JsonNullable<? extends List<FfmpegProfile>> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = profiles;
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(boolean record) {
            Utils.checkNotNull(record, "record");
            this.record = Optional.ofNullable(record);
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(Optional<Boolean> record) {
            Utils.checkNotNull(record, "record");
            this.record = record;
            return this;
        }

        public Builder recordingSpec(NewStreamPayloadRecordingSpec recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = Optional.ofNullable(recordingSpec);
            return this;
        }

        public Builder recordingSpec(Optional<? extends NewStreamPayloadRecordingSpec> recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = recordingSpec;
            return this;
        }

        public Builder multistream(Multistream multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = Optional.ofNullable(multistream);
            return this;
        }

        public Builder multistream(Optional<? extends Multistream> multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = multistream;
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Map<String, UserTags> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = Optional.ofNullable(userTags);
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Optional<? extends Map<String, UserTags>> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = userTags;
            return this;
        }
        
        public NewStreamPayload build() {
            return new NewStreamPayload(
                name,
                pull,
                creatorId,
                playbackPolicy,
                profiles,
                record,
                recordingSpec,
                multistream,
                userTags);
        }
    }
}

