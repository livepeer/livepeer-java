/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package studio.livepeer.livepeer.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
import studio.livepeer.livepeer.utils.Utils;


public class StreamPatchPayload {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private Optional<? extends InputCreatorId> creatorId;

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("record")
    private Optional<Boolean> record;

    /**
     * If currently suspended
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("suspended")
    private Optional<Boolean> suspended;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("multistream")
    private Optional<? extends Multistream> multistream;

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackPolicy")
    private JsonNullable<? extends PlaybackPolicy> playbackPolicy;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profiles")
    private JsonNullable<? extends List<FfmpegProfile>> profiles;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recordingSpec")
    private Optional<? extends RecordingSpec> recordingSpec;

    /**
     * User input tags associated with the stream
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userTags")
    private Optional<? extends Map<String, UserTags>> userTags;

    @JsonCreator
    public StreamPatchPayload(
            @JsonProperty("creatorId") Optional<? extends InputCreatorId> creatorId,
            @JsonProperty("record") Optional<Boolean> record,
            @JsonProperty("suspended") Optional<Boolean> suspended,
            @JsonProperty("multistream") Optional<? extends Multistream> multistream,
            @JsonProperty("playbackPolicy") JsonNullable<? extends PlaybackPolicy> playbackPolicy,
            @JsonProperty("profiles") JsonNullable<? extends List<FfmpegProfile>> profiles,
            @JsonProperty("recordingSpec") Optional<? extends RecordingSpec> recordingSpec,
            @JsonProperty("userTags") Optional<? extends Map<String, UserTags>> userTags) {
        Utils.checkNotNull(creatorId, "creatorId");
        Utils.checkNotNull(record, "record");
        Utils.checkNotNull(suspended, "suspended");
        Utils.checkNotNull(multistream, "multistream");
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        Utils.checkNotNull(profiles, "profiles");
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        Utils.checkNotNull(userTags, "userTags");
        this.creatorId = creatorId;
        this.record = record;
        this.suspended = suspended;
        this.multistream = multistream;
        this.playbackPolicy = playbackPolicy;
        this.profiles = profiles;
        this.recordingSpec = recordingSpec;
        this.userTags = userTags;
    }
    
    public StreamPatchPayload() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<InputCreatorId> creatorId() {
        return (Optional<InputCreatorId>) creatorId;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    @JsonIgnore
    public Optional<Boolean> record() {
        return record;
    }

    /**
     * If currently suspended
     */
    @JsonIgnore
    public Optional<Boolean> suspended() {
        return suspended;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Multistream> multistream() {
        return (Optional<Multistream>) multistream;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PlaybackPolicy> playbackPolicy() {
        return (JsonNullable<PlaybackPolicy>) playbackPolicy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<FfmpegProfile>> profiles() {
        return (JsonNullable<List<FfmpegProfile>>) profiles;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<RecordingSpec> recordingSpec() {
        return (Optional<RecordingSpec>) recordingSpec;
    }

    /**
     * User input tags associated with the stream
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, UserTags>> userTags() {
        return (Optional<Map<String, UserTags>>) userTags;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public StreamPatchPayload withCreatorId(InputCreatorId creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = Optional.ofNullable(creatorId);
        return this;
    }

    public StreamPatchPayload withCreatorId(Optional<? extends InputCreatorId> creatorId) {
        Utils.checkNotNull(creatorId, "creatorId");
        this.creatorId = creatorId;
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public StreamPatchPayload withRecord(boolean record) {
        Utils.checkNotNull(record, "record");
        this.record = Optional.ofNullable(record);
        return this;
    }

    /**
     * Should this stream be recorded? Uses default settings. For more
     * customization, create and configure an object store.
     * 
     */
    public StreamPatchPayload withRecord(Optional<Boolean> record) {
        Utils.checkNotNull(record, "record");
        this.record = record;
        return this;
    }

    /**
     * If currently suspended
     */
    public StreamPatchPayload withSuspended(boolean suspended) {
        Utils.checkNotNull(suspended, "suspended");
        this.suspended = Optional.ofNullable(suspended);
        return this;
    }

    /**
     * If currently suspended
     */
    public StreamPatchPayload withSuspended(Optional<Boolean> suspended) {
        Utils.checkNotNull(suspended, "suspended");
        this.suspended = suspended;
        return this;
    }

    public StreamPatchPayload withMultistream(Multistream multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = Optional.ofNullable(multistream);
        return this;
    }

    public StreamPatchPayload withMultistream(Optional<? extends Multistream> multistream) {
        Utils.checkNotNull(multistream, "multistream");
        this.multistream = multistream;
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public StreamPatchPayload withPlaybackPolicy(PlaybackPolicy playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = JsonNullable.of(playbackPolicy);
        return this;
    }

    /**
     * Whether the playback policy for an asset or stream is public or signed
     */
    public StreamPatchPayload withPlaybackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
        Utils.checkNotNull(playbackPolicy, "playbackPolicy");
        this.playbackPolicy = playbackPolicy;
        return this;
    }

    public StreamPatchPayload withProfiles(List<FfmpegProfile> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = JsonNullable.of(profiles);
        return this;
    }

    public StreamPatchPayload withProfiles(JsonNullable<? extends List<FfmpegProfile>> profiles) {
        Utils.checkNotNull(profiles, "profiles");
        this.profiles = profiles;
        return this;
    }

    public StreamPatchPayload withRecordingSpec(RecordingSpec recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = Optional.ofNullable(recordingSpec);
        return this;
    }

    public StreamPatchPayload withRecordingSpec(Optional<? extends RecordingSpec> recordingSpec) {
        Utils.checkNotNull(recordingSpec, "recordingSpec");
        this.recordingSpec = recordingSpec;
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public StreamPatchPayload withUserTags(Map<String, UserTags> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = Optional.ofNullable(userTags);
        return this;
    }

    /**
     * User input tags associated with the stream
     */
    public StreamPatchPayload withUserTags(Optional<? extends Map<String, UserTags>> userTags) {
        Utils.checkNotNull(userTags, "userTags");
        this.userTags = userTags;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        StreamPatchPayload other = (StreamPatchPayload) o;
        return 
            Objects.deepEquals(this.creatorId, other.creatorId) &&
            Objects.deepEquals(this.record, other.record) &&
            Objects.deepEquals(this.suspended, other.suspended) &&
            Objects.deepEquals(this.multistream, other.multistream) &&
            Objects.deepEquals(this.playbackPolicy, other.playbackPolicy) &&
            Objects.deepEquals(this.profiles, other.profiles) &&
            Objects.deepEquals(this.recordingSpec, other.recordingSpec) &&
            Objects.deepEquals(this.userTags, other.userTags);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            creatorId,
            record,
            suspended,
            multistream,
            playbackPolicy,
            profiles,
            recordingSpec,
            userTags);
    }
    
    @Override
    public String toString() {
        return Utils.toString(StreamPatchPayload.class,
                "creatorId", creatorId,
                "record", record,
                "suspended", suspended,
                "multistream", multistream,
                "playbackPolicy", playbackPolicy,
                "profiles", profiles,
                "recordingSpec", recordingSpec,
                "userTags", userTags);
    }
    
    public final static class Builder {
 
        private Optional<? extends InputCreatorId> creatorId = Optional.empty();
 
        private Optional<Boolean> record = Optional.empty();
 
        private Optional<Boolean> suspended = Optional.empty();
 
        private Optional<? extends Multistream> multistream = Optional.empty();
 
        private JsonNullable<? extends PlaybackPolicy> playbackPolicy = JsonNullable.undefined();
 
        private JsonNullable<? extends List<FfmpegProfile>> profiles = JsonNullable.undefined();
 
        private Optional<? extends RecordingSpec> recordingSpec = Optional.empty();
 
        private Optional<? extends Map<String, UserTags>> userTags = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder creatorId(InputCreatorId creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = Optional.ofNullable(creatorId);
            return this;
        }

        public Builder creatorId(Optional<? extends InputCreatorId> creatorId) {
            Utils.checkNotNull(creatorId, "creatorId");
            this.creatorId = creatorId;
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(boolean record) {
            Utils.checkNotNull(record, "record");
            this.record = Optional.ofNullable(record);
            return this;
        }

        /**
         * Should this stream be recorded? Uses default settings. For more
         * customization, create and configure an object store.
         * 
         */
        public Builder record(Optional<Boolean> record) {
            Utils.checkNotNull(record, "record");
            this.record = record;
            return this;
        }

        /**
         * If currently suspended
         */
        public Builder suspended(boolean suspended) {
            Utils.checkNotNull(suspended, "suspended");
            this.suspended = Optional.ofNullable(suspended);
            return this;
        }

        /**
         * If currently suspended
         */
        public Builder suspended(Optional<Boolean> suspended) {
            Utils.checkNotNull(suspended, "suspended");
            this.suspended = suspended;
            return this;
        }

        public Builder multistream(Multistream multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = Optional.ofNullable(multistream);
            return this;
        }

        public Builder multistream(Optional<? extends Multistream> multistream) {
            Utils.checkNotNull(multistream, "multistream");
            this.multistream = multistream;
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(PlaybackPolicy playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = JsonNullable.of(playbackPolicy);
            return this;
        }

        /**
         * Whether the playback policy for an asset or stream is public or signed
         */
        public Builder playbackPolicy(JsonNullable<? extends PlaybackPolicy> playbackPolicy) {
            Utils.checkNotNull(playbackPolicy, "playbackPolicy");
            this.playbackPolicy = playbackPolicy;
            return this;
        }

        public Builder profiles(List<FfmpegProfile> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = JsonNullable.of(profiles);
            return this;
        }

        public Builder profiles(JsonNullable<? extends List<FfmpegProfile>> profiles) {
            Utils.checkNotNull(profiles, "profiles");
            this.profiles = profiles;
            return this;
        }

        public Builder recordingSpec(RecordingSpec recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = Optional.ofNullable(recordingSpec);
            return this;
        }

        public Builder recordingSpec(Optional<? extends RecordingSpec> recordingSpec) {
            Utils.checkNotNull(recordingSpec, "recordingSpec");
            this.recordingSpec = recordingSpec;
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Map<String, UserTags> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = Optional.ofNullable(userTags);
            return this;
        }

        /**
         * User input tags associated with the stream
         */
        public Builder userTags(Optional<? extends Map<String, UserTags>> userTags) {
            Utils.checkNotNull(userTags, "userTags");
            this.userTags = userTags;
            return this;
        }
        
        public StreamPatchPayload build() {
            return new StreamPatchPayload(
                creatorId,
                record,
                suspended,
                multistream,
                playbackPolicy,
                profiles,
                recordingSpec,
                userTags);
        }
    }
}

